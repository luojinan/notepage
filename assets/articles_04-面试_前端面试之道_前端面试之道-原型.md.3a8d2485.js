import{_ as o,o as a,c as e,V as s}from"./chunks/framework.b450deef.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/04-面试/前端面试之道/前端面试之道-原型.md","filePath":"articles/04-面试/前端面试之道/前端面试之道-原型.md"}'),n={name:"articles/04-面试/前端面试之道/前端面试之道-原型.md"},t=s(`<h2 id="原型" tabindex="-1">原型 <a class="header-anchor" href="#原型" aria-label="Permalink to &quot;原型&quot;">​</a></h2><h3 id="打印数组" tabindex="-1">打印数组 <a class="header-anchor" href="#打印数组" aria-label="Permalink to &quot;打印数组&quot;">​</a></h3><p>当把一个变量打印出来时 👇数组，除了有项的值，还有一个<code>length</code>和</p><p><code>__proto__</code> 属性，指向了该数组的原型</p><blockquote><p>这个属性在现在来说已经不推荐直接去使用它了 这只是浏览器在早期为了让我们访问到内部属性 <code>[[prototype]]</code> 来实现的一个东西)</p></blockquote><p>👇 展开发现里面 <code>constructor</code> 属性也就是<strong>构造函数</strong>,是一个数组方法</p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221130184822.png" alt=""></p><p>👆 且还有一个原型<code>__proto__</code> 属性</p><p>👇 展开发现<code>constructor</code> 属性是一个对象方法，且没有更深层的原型了</p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221130184834.png" alt=""></p><h3 id="打印对象" tabindex="-1">打印对象 <a class="header-anchor" href="#打印对象" aria-label="Permalink to &quot;打印对象&quot;">​</a></h3><p>对象<code>原型__proto__</code>里<code>constructor</code> 属性是对象方法 👇 且没有更深层的原型了（比数组少一层</p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221130184847.png" alt=""></p><p>👆我们也可以得出数组本质上是一种特殊的对象</p><h3 id="创建没有原型的对象" tabindex="-1">创建没有原型的对象 <a class="header-anchor" href="#创建没有原型的对象" aria-label="Permalink to &quot;创建没有原型的对象&quot;">​</a></h3><p>可以利用<code>Object.create(null,{...})</code>创建一个没有原型的对象</p><p>👆没有<code>__proto__</code>，原因是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noreferrer">第一参数指定原型-MDN</a>，指定null则没有</p><h3 id="查看原型链方法" tabindex="-1">查看原型链方法 <a class="header-anchor" href="#查看原型链方法" aria-label="Permalink to &quot;查看原型链方法&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">obj1</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">hasOwnProperty</span><span style="color:#A6ACCD;">( </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">name</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;"> )</span></span></code></pre></div><p>查看name属性是否在obj1原型链上</p><h3 id="改变原型链方法" tabindex="-1">改变原型链方法 <a class="header-anchor" href="#改变原型链方法" aria-label="Permalink to &quot;改变原型链方法&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1. 赋值修改 prototype</span></span>
<span class="line"><span style="color:#FFCB6B;">obj1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">obj2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2. 调用Object.setPrototype函数</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setPrototype</span><span style="color:#A6ACCD;">( obj1 </span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> obj2 )</span></span></code></pre></div><p>obj2 替换掉obj1的原型中</p><h3 id="构造函数" tabindex="-1">构造函数 <a class="header-anchor" href="#构造函数" aria-label="Permalink to &quot;构造函数&quot;">​</a></h3><p>由函数 <code>func.call()</code> 可以 <code>.xx</code> 的调用形式可得出，函数也是 <a href="./前端面试之道-JS数据类型.html#基础原始类型">对象/引用类型</a></p><p>new 构造函数 ，可以创建对象</p><p>JS有内置的构造函数, <code>Array</code> <code>Object</code> <code>String</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [] </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 相当于</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> Array</span></span></code></pre></div><p>其他同理如</p><ul><li><code>{} --&gt; new Object</code></li><li><code>&#39;&#39; --&gt; new String</code></li></ul><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221130191128.png" alt=""> 👆 对象构造函数 <code>Object</code> 内有 <code>prototype -原型对象</code>（一般是Object）</p><p>并且这个属性的值和先前我们在 <code>__proto__</code> 中看到的一模一样</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20221130192228.png" alt=""></p><p>为什么 <code>obj</code> 可以访问到 <code>valueOf</code> 函数，就是因为 <code>obj</code> 通过原型链找到了 <code>valueOf</code> 函数</p><ul><li><code>Object</code> 是所有对象的爸爸，所有对象类型都可以通过 <code>__proto__</code> 找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li>函数的 <code>prototype</code> 是一个对象</li><li>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul>`,36),l=[t];function c(p,r,d,i,_,h){return a(),e("div",null,l)}const g=o(n,[["render",c]]);export{y as __pageData,g as default};
