import{_ as t,o as a,c as h,V as p}from"./chunks/framework.b450deef.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/01-深度学习/http/http2.md","filePath":"articles/01-深度学习/http/http2.md"}'),e={name:"articles/01-深度学习/http/http2.md"},l=p('<h2 id="懒人版" tabindex="-1">懒人版 <a class="header-anchor" href="#懒人版" aria-label="Permalink to &quot;懒人版&quot;">​</a></h2><p>http1.0每次请求都建立TCP断开TCP</p><p>http1.1只建立1个TCP连接，不断开，但是每个请求要按顺序排队 浏览器提供可以同时建立6-8个TCP连接，实现并发效果</p><p>http2只建立1个TCP连接，不断开，每个请求可以并发请求并且乱序响应</p><h2 id="http1-0的问题" tabindex="-1">http1.0的问题 <a class="header-anchor" href="#http1-0的问题" aria-label="Permalink to &quot;http1.0的问题&quot;">​</a></h2><p>每个http请求都要重新建立TCP连接，并且是等待上一个TCP连接结束断开连接之后才建立下一个TCP连接</p><h2 id="http1-1的问题" tabindex="-1">http1.1的问题 <a class="header-anchor" href="#http1-1的问题" aria-label="Permalink to &quot;http1.1的问题&quot;">​</a></h2><p>http1.1默认支持长连接(持久连接)来提升速度</p><p>http1.0则加一个 <code>Connetion:keep-alive</code> 即可开启</p><p>http1.1中手动关闭一个持久连接是 <code>Connetion:close</code></p><p>长连接虽然支持一个TCP连接同时发送多个http请求(http管道机制)，但是因为协议规定响应要按请求顺序返回，并且响应并不能同时返回，需要一个一个返回 因此会出现，前面的请求响应耗时导致虽然共用了1个TCP连接同时发起的请求，要等前面的响应完成才能响应（队头阻塞）</p><p>这样依然没能充分利用1个TCP连接的空闲时间</p><p>也正是因为1个TCP连接的请求效率在当下请求数越来越多,资源越来越大的互联网应用下是远远不够的 衍生了各种提升http并发性能的方法</p><ul><li>浏览器支持1个域名同时建立6-8个TCP连接，发起请求的时候会自动选择1条TCP连接去发送</li><li>资源放在不同域名下，让应用支持更多的TCP连接数</li><li>图片资源做成base64减少请求的数量，小图合并成雪碧图减少请求的数量</li><li>js资源打包成一个大chunk，来减少请求数量</li><li>资源懒加载</li></ul><p>队头阻塞体现在真实场景是，一个响应久的请求会占用一个TCP连接，导致原本6个可用的连接变少</p><p>浏览器不允许更多的TCP连接原因是：假设一个客户端可以同时建立无限制的TCP连接，客户数一多同一时间会对服务器造成很大压力(极端情况也就是DDOS攻击)</p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220226155840.png" alt=""></p><h2 id="http2的全双工模式" tabindex="-1">http2的全双工模式 <a class="header-anchor" href="#http2的全双工模式" aria-label="Permalink to &quot;http2的全双工模式&quot;">​</a></h2><p>http1.1的队头阻塞等问题，证明通过允许多个TCP连接并不能解决问题，必须要1个TCP连接支持并发才能很好的提高性能(同时解决建立多个TCP连接的耗时)</p><p>虽然http1.1实现了tcp的长连接，在一个tcp链接通道中，我们可以连续处理多个http请求响应，但是这个处理过程是半双工模式，也就是同一时刻只能处理一个request的请求或者响应，后面的request必须等到前面的请求响应之后才能进行。</p><ul><li>半双工：同一时间内，链接上只能有一方发送数据，另一方接受数据。</li><li>全双工：同一时间内，两端都可以发送或接受数据</li></ul><p>http/2实现了全双工通信，具体表现为：浏览器针对同一个域名的资源，只建立一个tcp连接通道，所有的针对这个域名的请求全部在这个通道中完成</p><p>即多个完整的http请求同时发送，发送的过程是有一定顺序的整体，服务端接收处理后乱序响应</p><p>不再按请求顺序返回，直接乱序响应(也可以通过设置优先级制定顺序)</p><h2 id="http2的多路复用" tabindex="-1">http2的多路复用 <a class="header-anchor" href="#http2的多路复用" aria-label="Permalink to &quot;http2的多路复用&quot;">​</a></h2><p>http2 基于把文本字符格式的http数改为流的形式，实现分割成帧，实现多个请求是交错发送，交错处理，在响应时组装成各自的响应</p><ul><li>浏览器还是只支持6-8个TCP连接</li><li>同域名下所有通信都在单个连接上完成</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰</li><li>该连接可以承载任意数量的双向数据流。</li><li>每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li><li>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装</li></ul><h2 id="http2的并发效果" tabindex="-1">http2的并发效果 <a class="header-anchor" href="#http2的并发效果" aria-label="Permalink to &quot;http2的并发效果&quot;">​</a></h2><p>在上述http1.1和http2的区分下</p><p>在实际效果上会发现一些应用http2并没有提升多少速度</p><p>这里分析一下原因</p><ul><li>同时建立6个TCP连接并且没有队头阻塞的情况下,http1.1与http2对比的性能损耗主要在建立另外5个TCP连接上</li><li>以及每6个连接的请求耗时如果时间都不长，或者要并发的数量其实没有很多，看上去就会和http2并发所有请求区别不会很大</li><li>假如我们是本地启前端静态服务器，并发很多请求在http1.1下会跟http2没多大区别，因为建立TCP连接很快，响应也很快</li></ul><p>所以http2更明显的效果要体现在</p><ul><li>多图场景</li><li>音视频场景</li><li>ESM模块化场景，ESBuild等</li></ul><h2 id="http2的头部压缩" tabindex="-1">http2的头部压缩 <a class="header-anchor" href="#http2的头部压缩" aria-label="Permalink to &quot;http2的头部压缩&quot;">​</a></h2><ul><li>索引表 常用单词转为索引匹配</li><li>压缩编码HPACK</li></ul><h2 id="http2的二进制流-http1-1是字符串-流更容易分割" tabindex="-1">http2的二进制流: http1.1是字符串，流更容易分割 <a class="header-anchor" href="#http2的二进制流-http1-1是字符串-流更容易分割" aria-label="Permalink to &quot;http2的二进制流: http1.1是字符串，流更容易分割&quot;">​</a></h2><ul><li>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</li></ul><h2 id="http2的服务器推送" tabindex="-1">http2的服务器推送 <a class="header-anchor" href="#http2的服务器推送" aria-label="Permalink to &quot;http2的服务器推送&quot;">​</a></h2><ul><li>服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</li></ul><h2 id="用nodejs手写http2静态服务器和http1-1静态服务器对比" tabindex="-1">用nodejs手写http2静态服务器和http1.1静态服务器对比 <a class="header-anchor" href="#用nodejs手写http2静态服务器和http1-1静态服务器对比" aria-label="Permalink to &quot;用nodejs手写http2静态服务器和http1.1静态服务器对比&quot;">​</a></h2><p>TODO:</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><h3 id="http2多路复用和http1-1的长连接keep-alive的区别" tabindex="-1">http2多路复用和http1.1的长连接keep-alive的区别 <a class="header-anchor" href="#http2多路复用和http1-1的长连接keep-alive的区别" aria-label="Permalink to &quot;http2多路复用和http1.1的长连接keep-alive的区别&quot;">​</a></h3><p>长连接1个TCP连接同一时间只能处理一个请求 只能有一方发送数据，另一方接受数据。 多路复用是1个TCP同一时间处理多个请求</p><h3 id="为什么http1-1不能实现多路复用" tabindex="-1">为什么http1.1不能实现多路复用 <a class="header-anchor" href="#为什么http1-1不能实现多路复用" aria-label="Permalink to &quot;为什么http1.1不能实现多路复用&quot;">​</a></h3><p>字符串文本分割解析，在响应时如果处理多个请求，不能知道属于哪个请求的响应</p><h3 id="在不改动-http-1-1-的语义、方法、状态码、uri-以及首部字段等等的情况下-http-2-是如何过渡到http1-1呢" tabindex="-1">在不改动 HTTP/1.1 的语义、⽅法、状态码、URI 以及⾸部字段等等的情况下, HTTP/2 是如何过渡到http1.1呢? <a class="header-anchor" href="#在不改动-http-1-1-的语义、方法、状态码、uri-以及首部字段等等的情况下-http-2-是如何过渡到http1-1呢" aria-label="Permalink to &quot;在不改动 HTTP/1.1 的语义、⽅法、状态码、URI 以及⾸部字段等等的情况下, HTTP/2 是如何过渡到http1.1呢?&quot;">​</a></h3><p>关键之⼀就是在应⽤层(HTTP/2)和传输层(TCP or UDP)之间增加⼀个⼆进制分帧层</p><h3 id="promise实现控制最大并发量-控制响应顺序" tabindex="-1">promise实现控制最大并发量，控制响应顺序 <a class="header-anchor" href="#promise实现控制最大并发量-控制响应顺序" aria-label="Permalink to &quot;promise实现控制最大并发量，控制响应顺序&quot;">​</a></h3><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://ye11ow.gitbooks.io/http2-explained/content/part2.html" target="_blank" rel="noreferrer">http2-中文文档</a></li><li><a href="https://www.bilibili.com/video/BV1p541147LD" target="_blank" rel="noreferrer">http2-视频</a></li></ul>',52),i=[l];function r(o,n,s,d,c,u){return a(),h("div",null,i)}const b=t(e,[["render",r]]);export{T as __pageData,b as default};
