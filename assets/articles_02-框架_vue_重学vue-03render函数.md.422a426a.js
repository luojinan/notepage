import{_ as e,o,c as l,V as s}from"./chunks/framework.b450deef.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/02-框架/vue/重学vue-03render函数.md","filePath":"articles/02-框架/vue/重学vue-03render函数.md"}'),a={name:"articles/02-框架/vue/重学vue-03render函数.md"},c=s(`<h2 id="前情提要" tabindex="-1">前情提要 <a class="header-anchor" href="#前情提要" aria-label="Permalink to &quot;前情提要&quot;">​</a></h2><p>按照vue的官方文档，本应先看vue的指令(<code>v-model、v-show、v-for</code>...) 这里在讲指令之前，我们先讲vue的<code>render函数</code>，因为vue的指令解析之后就是作用于<code>render函数</code></p><blockquote><p><a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noreferrer">Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。</a></p></blockquote><p>要理解render就要知道Vue的DOM渲染过程</p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220316194111.png" alt=""></p><p>👆我们知道Vue用的是<code>虚拟DOM</code>渲染成<code>真实DOM</code>(关于<code>虚拟DOM</code>的意义、性能\`，我们会另外分析)</p><blockquote><p>我们把这样的节点描述为<code>“虚拟节点 (virtual node)”</code>，也常简写它为<code>“VNode”</code></p><p><code>“虚拟 DOM”</code>是我们对由 <code>Vue</code> 组件树建立起来的整个 <code>VNode 树</code>的称呼</p></blockquote><ul><li><code>VNode</code>: 虚拟节点</li><li><code>虚拟DOM</code>: <code>虚拟DOM</code>树(由各种虚拟节点组成)</li></ul><p>👆 官方文档对<code>虚拟DOM</code>的解释，我们需要知道<code>虚拟DOM</code>并不是Vue独有的东西 仅仅是概念，不影响我们对整体的学习，但是我们还是区分好以免造成概念混淆</p><hr><p><strong>思考🤔</strong></p><ul><li>那我们平时写的代码就是<code>虚拟DOM</code>了吗？</li><li><code>虚拟DOM</code>渲染真实DOM的步骤发生在哪里呢？</li></ul><p>我们平时写的代码是<code>.vue</code>文件的<code>&lt;template&gt;</code>模版 或者像前面讲解Vue的模板语法功能的示例代码，写<code>new Vue</code>的配置项<code>template:&#39;&lt;p&gt;123&lt;/p&gt;&#39;</code> 很明显，这些都不是VNode，也不是真实DOM</p><p>我们写出来的<code>.vue</code>文件会经过打包工具如<code>webpack</code>的解析(借助<code>vue-loader</code>)，打包成<code>render函数</code>的js</p><p>打包上线后，浏览器执行这段<code>render函数</code>生成VNode，再由vue内部决定在什么时机渲染成真实DOM</p><p>注意: 容易有的误区，我们常用的vue库版本是runtime版，这个版本不支持直接写template的代码渲染成真实DOM，<a href="./重学vue-01模板语法.html#\`、运行时版-runtime">vue对外的资源js为什么这么多版本</a>中我们尝试用runtime版运行模版语法会报错，runtime版只能通过<code>render函数</code>渲染出真实DOM</p><hr><h2 id="写一个不考虑虚拟dom的render" tabindex="-1">写一个不考虑虚拟dom的render <a class="header-anchor" href="#写一个不考虑虚拟dom的render" aria-label="Permalink to &quot;写一个不考虑虚拟dom的render&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"></span></code></pre></div><blockquote><p>我们现在先把注意力放在单个的<code>虚拟节点</code>上，不考虑树状<code>虚拟DOM</code>的数据协作(后面再补)</p></blockquote><p>下面用<code>VNode</code>指代<code>虚拟节点</code></p><h2 id="render参数对象" tabindex="-1">render参数对象 <a class="header-anchor" href="#render参数对象" aria-label="Permalink to &quot;render参数对象&quot;">​</a></h2><p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1" target="_blank" rel="noreferrer">渲染函数&amp;JSX - 官方文档</a></p><p>注意的写渲染函数不支持vue的语法糖指令</p><p>另外，渲染函数执行后返回的是一个<code>VNode</code>对象</p><p>我们可以打印一下 <code>VNode</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> config </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">el</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">#app</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">render</span><span style="color:#89DDFF;">:(</span><span style="color:#A6ACCD;font-style:italic;">h</span><span style="color:#89DDFF;">)</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">VNode</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">h</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">h1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,{},</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">测试render</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">Vnode</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">VNode</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 注意render配置项 函数要返回VNode</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Vue</span><span style="color:#A6ACCD;">(config)</span></span></code></pre></div><p>👆 可以看到一个<code>VNode</code>里面是带着真实DOM的，所以虚拟DOM并没有办法脱离真实DOM的范畴，并且在浏览器内存中存着一份真实DOM 甚至绕过虚拟DOM,直接操作DOM性能会更好</p><p>思考🤔: 虚拟DOM到底有什么好处</p><h2 id="写render和template的区别" tabindex="-1">写render和template的区别 <a class="header-anchor" href="#写render和template的区别" aria-label="Permalink to &quot;写render和template的区别&quot;">​</a></h2><p>就像官方文档说的，一般我们不关心<code>render函数</code>，也不关心<code>VNode</code>、<code>真实DOM</code></p><p>但是官方还是把render开放出来给我们使用，并列举了一些使用场景</p><p>如果单论我们开发时应该写<code>render函数</code>还是写模版<code>template</code>，我们来分析一下区别：</p><ul><li>优点 <ul><li>因为最终打包后的代码都是<code>render函数</code>,所以写<code>template</code>需要打包的编译耗时,render会减少打包时间</li><li>特定场景下，利用js比起用template可以更好的编写内容</li></ul></li><li>缺点 <ul><li>额外的学习成本</li><li>需要自己实现vue在模版上提供的语法糖,如<code>v-show</code>、<code>v-model</code></li></ul></li></ul><p>注意: 容易有的误区，写 <code>render函数</code> 并不会提升代码<strong>运行时的速度</strong></p><h2 id="jsx" tabindex="-1">JSX <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;JSX&quot;">​</a></h2><blockquote><p>起源于<code>react</code>，用<code>html</code>语法写成js的<code>render</code></p></blockquote><p>有趣的是:</p><ul><li>我们为了在<code>js</code>中写<code>html</code>，而引入<code>模版语法</code></li><li>现在又为了在<code>js</code>中用<code>html</code>语法，而引入<code>jsx语法</code></li></ul><h3 id="转译" tabindex="-1">转译 <a class="header-anchor" href="#转译" aria-label="Permalink to &quot;转译&quot;">​</a></h3><blockquote><p><code>jsx</code>并不是浏览器或者<code>nodejs</code>环境认识的语法，因此需要转译工具的帮忙</p></blockquote><ul><li>在<code>react</code>中，是用<code>.jsx</code>文件配合<code>babel</code>，转译成<code>render函数</code></li><li>在<code>vue</code>中，是用<code>.vue</code>文件，配合原来的<code>vue-loader</code>外加vue的<code>jsx-babel</code>,转译成<code>render函数</code></li></ul><p>到这里，我们再来捋一下vue的几种转译流程</p><ol><li><code>runtime版</code>vue，在开发阶段直接就写<code>render函数</code>，给浏览器运行</li><li><code>runtime版</code>vue，写<code>template</code>，通过打包工具转译为<code>render函数</code>，给浏览器运行</li><li><code>完整版</code>vue，写<code>template</code>，在浏览器运行时，通过库内的<code>vue.complier</code>解析<code>template</code>成<code>render函数</code></li><li>与vue版本无关，开发阶段写render并用<code>jsx语法</code>，通过打包工具转译成<code>render函数</code>，给浏览器运行</li></ol><p>思考🤔：现在的工程支不支持写<code>jsx</code>，支持的话，是怎么配置打包工具来支持的？</p><h2 id="函数式组件" tabindex="-1">函数式组件 <a class="header-anchor" href="#函数式组件" aria-label="Permalink to &quot;函数式组件&quot;">​</a></h2><blockquote><p>在vue3中废弃</p></blockquote><p>优点：</p><ul><li>组件初始化，轻量 <ul><li>没有组件实例化(<code>new vnode.componentOptions.Ctor(options)</code>)，函数式组件获取VNode仅仅是普通函数调用</li><li>无公共属性、方法拷贝</li><li>无生命周期钩子调用</li></ul></li><li>DOM树渲染、更新速度快(直接挂载到父组件中，缩短首次渲染、diff更新路径) <ul><li>父组件生成VNode时，函数式组件render方法会被调用，生成VNode挂载到父组件children中，patch阶段可直接转换成真是DOM,普通组件则在createElm时，走组件初始化流程。</li><li>diff更新时，函数式组件调用render，直接创建普通VNode，而普通组件创建的VNode的是包含组件作用域的，diff操作时，还有额外调用updateChildComponent更新属性、自定义事件等，调用链路会比较长。</li></ul></li></ul>`,49),n=[c];function d(p,r,t,i,u,D){return o(),l("div",null,n)}const F=e(a,[["render",d]]);export{y as __pageData,F as default};
