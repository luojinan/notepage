import{_ as s,o,c as e,V as n}from"./chunks/framework.b450deef.js";const C=JSON.parse('{"title":"tsconfig配置理解","description":"","frontmatter":{},"headers":[],"relativePath":"articles/01-深度学习/typescript/1-tsconfig配置理解.md","filePath":"articles/01-深度学习/typescript/1-tsconfig配置理解.md"}'),a={name:"articles/01-深度学习/typescript/1-tsconfig配置理解.md"},l=n(`<h1 id="tsconfig配置理解" tabindex="-1">tsconfig配置理解 <a class="header-anchor" href="#tsconfig配置理解" aria-label="Permalink to &quot;tsconfig配置理解&quot;">​</a></h1><p><code>tsconfig.json</code> 将会把一个文件夹转换为「项目」，如果不指定任何 <code>exclude</code> 或者 <code>files</code>，则包含在 <code>tsconfig.json</code> 中的所有文件夹中的所有文件都会被包含在编译中。</p><p>和 <code>node</code> 指令运行 <code>js</code> 时寻找 <code>node_modules</code> 一样</p><p>运行方(<code>tsc</code>)指令来运行 <code>ts</code> 会有一个寻找 <code>tsconfig.json</code> 的过程</p><p>运行方(转译ts的工具)在这里是: <code>tsx/esno</code>，其他的如：<code>ts-node</code>、<code>tsc</code>、<code>webpack-ts-loader</code> ...</p><p>🤔 其他具有 <strong>配置文件</strong> 并且 <strong>默认识别配置文件</strong> 机制的前端构建工具(<code>webpack</code>、<code>vite</code>)，其实也有这种寻找机制(只会从当前执行命令根目录寻找)，而因为 <code>tsconfig的寻址</code> 和 <code>node_modules寻址</code> 完全一致因此拿出来对比</p><p>都没找到配置文件时会有写死的 <strong>默认配置</strong>，对应 <code>node_modules</code> 的全局依赖</p><p>注意：只有直接使用 <code>tsc</code> 指令才会自动寻址，当写了指令参数如 <code>tsc src/index.ts</code> 将会理解为不需要自定义配置而使用默认配置(就是 <code>tsc --init</code> 自动生成的那份配置)，即使项目目录中有 <code>tsconfig.json</code></p><h2 id="顶层配置项" tabindex="-1">顶层配置项 <a class="header-anchor" href="#顶层配置项" aria-label="Permalink to &quot;顶层配置项&quot;">​</a></h2><p>我们使用 <code>tsc --init</code> 生成出来的 <code>tsconfig.json</code> 只有 <code>compilerOptions</code> ，但其实和 <code>compilerOptions</code> 同级的其他配置也是需要了解的</p><p>外层 <code>tsconfig</code> 配置</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compilerOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// ✨ 以下与compilerOptions同级的配置项</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compileOnSave</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">files</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[],</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">include</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[],</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">exclude</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[],</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">references</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><table><thead><tr><th>配置项</th><th>说明</th></tr></thead><tbody><tr><td>compilerOptions</td><td>编译选项，详见compilerOptions</td></tr><tr><td>-</td><td>-</td></tr><tr><td>compileOnSave</td><td>让IDE在保存文件的时候根据tsconfig.json重新生成文件,要想支持这个特性需要Visual Studio 2015， TypeScript1.8.4以上并且安装atom-typescript插件</td></tr><tr><td>files</td><td>指定一个包含相对或绝对文件路径的列表</td></tr><tr><td>include</td><td>指定一个文件glob匹配模式列表，注意：<code>src/*</code> 只扫描src一级目录</td></tr><tr><td>exclude</td><td>指定一个文件glob匹配模式列表</td></tr><tr><td>extends</td><td>继承其他配置文件，如基础配置 <code>tsconfig.base.json</code></td></tr><tr><td>references</td><td>一个对象的数组，指明要引用的工程。path属性可以指向到包含tsconfig.json文件的目录，或者直接指向到配置文件本身（名字是任意的）</td></tr></tbody></table><p>我们一般不使用 TS 的 <a href="./0-TS入门.html#现代前端项目的选择">编译功能</a>，不需要实时编译 <code>compileOnSave</code></p><h2 id="入口配置files、include、exclude" tabindex="-1">入口配置files、include、exclude <a class="header-anchor" href="#入口配置files、include、exclude" aria-label="Permalink to &quot;入口配置files、include、exclude&quot;">​</a></h2><p>我们创建 TS 项目，什么都不配置时有一份默认配置</p><p>这也是很多入门教程：</p><ol><li>创建 <code>src/index.ts</code> 编写内容</li><li>直接运行 <code>npx tsc</code> 指令</li><li>查看生成的 <code>src/index.js</code> 内容</li></ol><p>看这些步骤和结果，可以猜测： <code>TS</code> 至少默认设置了 入口、出口、转译级别</p><p>而入口的配置就是 <code>tsconfig.json</code> 外层的 <code>files、include、exclude</code> 属性</p><p>这里要注意:</p><ul><li>不指定files选项值时，includes的默认值为<code>[&quot;**/*&quot;]</code> (包含当前项目中所有文件)</li><li>指定了files选项值时，includes 的默认值为<code>[]</code> (根据依赖分析自动识别需要包含的文件)</li></ul><p>如：<code>files</code> 设置为 <code>[&#39;src/index.ts&#39;]</code> 则该文件依赖的其他文件也会被归纳为编译对象</p><p>即 <code>index.ts</code> 依赖 <code>user.ts</code> 时，不需要在 <code>files</code> 中指定 <code>user.ts</code> ， <code>user.ts</code> 会自动纳入待编译文件</p><p>而 <code>files</code> 配置项在复杂项目时并不适用，此时我们使用 <code>include、exclude</code> 指定目录，而不是配置 <code>files</code></p><p><code>exclude</code> 的默认值是 <code>[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</code> + <code>outDir选项指定的值</code>, 如果有一些文件实在不想被 <code>TS</code> 扫描，才手动配置(<code>node_modules</code>不会被覆盖而是合并)</p><p>注意以下情况，<code>exclude</code> 中指定的被忽略文件，将会无效，依然被扫描：👇</p><ol><li><code>import</code>操作符</li><li><code>types</code>操作符</li><li><code>///&lt;reference</code>操作符</li><li>在<code>files</code>选项中添加配置的方式</li></ol><p>如 umi 项目配置：👇</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">include</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">mock/**/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src/**/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">typings/**/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">config/**/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.eslintrc.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.stylelintrc.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.prettierrc.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">mock/*</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">exclude</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">node_modules</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">build</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">dist</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src/.umi/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">webpack</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>可以看出一般：</p><ul><li><code>include</code><ul><li>src目录下的业务代码(路由页面、组件、工具方法等)</li><li>根目录下的配置文件(<code>eslintrc、prettierrc、stylelintrc</code>)</li></ul></li><li><code>exclude</code><ul><li>打包产物 <code>dist/</code></li><li>nodejs脚本 <code>scripts/</code></li><li>umi 自动生成的内容 <code>src/.umi/</code></li></ul></li></ul><blockquote><p>🤔 为什么包括js文件,不能编写类型语法，会有类型提示？</p></blockquote><blockquote><p><a href="#js相关allowjs-checkjs">js相关allowjscheckjs</a></p></blockquote><h2 id="复用配置references、extends" tabindex="-1">复用配置references、extends <a class="header-anchor" href="#复用配置references、extends" aria-label="Permalink to &quot;复用配置references、extends&quot;">​</a></h2><p><a href="https://www.typescriptlang.org/docs/handbook/project-references.html" target="_blank" rel="noreferrer">Project References - ts Docs</a></p><ul><li><code>references</code> - 参考</li><li><code>extends</code> - 继承</li></ul><table><thead><tr><th>_</th><th>_</th></tr></thead><tbody><tr><td>extends</td><td>继承其他配置文件，如基础配置 <code>tsconfig.base.json</code></td></tr><tr><td>references</td><td>一个对象的数组，指明要引用的工程。path属性可以指向到包含tsconfig.json文件的目录，或者直接指向到配置文件本身（名字是任意的）</td></tr></tbody></table><p>这里 <code>extends</code> 才是我们平时理解的复用，多份 <code>tsconfig</code> 配置 作用于 <strong>单入口</strong>，<code>tsconfig.base.json</code>.</p><p>因此不过多介绍 <code>extends</code>，把重点放在理解 <code>references</code>上</p><p><code>references</code> 是为了让我们针对多入口配置 <code>单/多份tsconfig</code> 作用于 <strong>不同的入口</strong></p><ol><li>我们可以想象 <strong>单元测试项目</strong> 结构：👇</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">├── src/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── index.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">├── test/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── index-tests.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">└── tsconfig.json</span></span></code></pre></div><p><code>test</code> 脚本运行在 <code>nodejs</code> 环境，<code>src</code> 源码运行在浏览器环境</p><p>👆 虽然可以分别创建不同的 <code>tsconfig</code> ，运行两次独立的tsc。但是这样并不优雅，并且启动多次 <code>tsc</code> 的损耗也不小</p><ol start="2"><li>我们也可以想象 <strong>现代构建工具的项目</strong> 结构：👇</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">├── build/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   ├── build.dev.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── build.prod.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">├── src/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── index.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">├── vite.config.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">├── webpack.config.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">└── tsconfig.json</span></span></code></pre></div><p>除了 <code>src</code> 目录运行在浏览器环境，其他ts运行在 nodejs环境</p><ol start="3"><li>我们再想象 <strong>SSR项目</strong> ：👇</li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">/</span></span>
<span class="line"><span style="color:#A6ACCD;">├── service/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── index.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">├── src/</span></span>
<span class="line"><span style="color:#A6ACCD;">│   └── index.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">└── tsconfig.json</span></span></code></pre></div><p>前端项目和后端node项目放在同一个目录下开发</p><p>👆 这些情况都是现代前端项目常见且不可避免的问题，我们希望不给浏览器端代码使用 <code>node api</code> ，同理 不给 node 环境使用 <code>浏览器api</code></p><p>此时可以定义一份 <code>主tsconfig</code> ，<code>references</code> 一份其他入口配置的 <code>tsconfig</code></p><h3 id="vitedemo的references和extends" tabindex="-1">ViteDemo的references和extends <a class="header-anchor" href="#vitedemo的references和extends" aria-label="Permalink to &quot;ViteDemo的references和extends&quot;">​</a></h3><p>在 <code>Vite</code> 创建的应用项目时，分为 <code>浏览器端</code> 以及 <code>本地构建服务的node环境</code></p><p>👇 <code>viteDemo/tsconfig.json</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compilerOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">baseUrl</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">.</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">paths</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F78C6C;">@/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./src/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">include</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">env.d.ts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src/**/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src/**/*.vue</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">],</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">@vue/tsconfig/tsconfig.web.json</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">references</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">path</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./tsconfig.config.json</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>👆 1. 入口范围指定为业务代码，不包括构建工具文件 2. 使用 <code>extends</code> 复用 <code>@vue/</code> 官方库中的浏览器环境<code>web</code>配置；3. 使用 <code>references</code> 复用同一个 <code>tsc</code> 进程而不是复用配置文件，处理其他入口(<code>node</code>)和相应的配置</p><p>👇 <code>viteDemo/tsconfig.config.json</code></p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compilerOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">composite</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">types</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">node</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">include</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vite.config.*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">vitest.config.*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">cypress.config.*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">playwright.config.*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">],</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">extends</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">@vue/tsconfig/tsconfig.node.json</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>👆 同理 1.入口范围指定为vite构建工具文件 2. 使用 <code>extends</code> 复用 <code>@vue/</code> 官方库中的 <code>node</code> 配置</p><h2 id="tsc-init" tabindex="-1">tsc --init <a class="header-anchor" href="#tsc-init" aria-label="Permalink to &quot;tsc --init&quot;">​</a></h2><p>👇 <code>tsc --init</code> 生成 <code>tsconfig.json</code> 文件</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">compilerOptions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">/* Basic Options */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">target</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">es5</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">                                </span><span style="color:#676E95;font-style:italic;">/* Specify ECMAScript target version: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, &#39;ES2018&#39;, &#39;ES2019&#39;, &#39;ES2020&#39;, &#39;ES2021&#39;, or &#39;ESNEXT&#39;. */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">commonjs</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">                           </span><span style="color:#676E95;font-style:italic;">/* Specify module code generation: &#39;none&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39;, &#39;es2015&#39;, &#39;es2020&#39;, or &#39;ESNext&#39;. */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">/* Strict Type-Checking Options */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">strict</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span><span style="color:#A6ACCD;">                                 </span><span style="color:#676E95;font-style:italic;">/* Enable all strict type-checking options. */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">esModuleInterop</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span><span style="color:#A6ACCD;">                        </span><span style="color:#676E95;font-style:italic;">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#39;allowSyntheticDefaultImports&#39;. */</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">/* Advanced Options */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">skipLibCheck</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true,</span><span style="color:#A6ACCD;">                           </span><span style="color:#676E95;font-style:italic;">/* Skip type checking of declaration files. */</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">forceConsistentCasingInFileNames</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">true</span><span style="color:#A6ACCD;">        </span><span style="color:#676E95;font-style:italic;">/* Disallow inconsistently-cased references to the same file. */</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="target" tabindex="-1">target <a class="header-anchor" href="#target" aria-label="Permalink to &quot;target&quot;">​</a></h2><p><code>ts</code> 转译后的 <code>js</code> 语法级别</p><p>✨ <code>dev</code> 阶段一般用 <code>ESNEXT</code></p><blockquote><p>🤔 如何区分 <code>dev</code> 和 <code>prod</code> 阶段的 <code>ts转译</code> ？</p></blockquote><blockquote><p>不需要考虑 <code>prod</code>, 现代构建工具 <strong>ts转译不处理语法，而是直接擦除</strong>，由其他工具如 <code>babel</code>、<code>swc</code> 做语法转译</p></blockquote><blockquote><p>🤔 ts 不参与构建阶段，库开发呢？</p><p>库开发一般也用其他成熟的构建工具(<code>esbuild/tsup</code>)，项目简单到可以使用 <code>tsc</code> 时则，可以通过指令指定配置文件 <code>tsc -p tsconfig.[build/dev].json</code></p></blockquote><p>上面提到：</p><blockquote><p>注意：只有直接使用 <code>tsc</code> 指令才会自动寻址，当写了指令参数如 <code>tsc src/index.ts</code> 将会理解为不需要自定义配置而使用默认配置(就是 <code>tsc --init</code> 自动生成的那份配置)，即使项目目录中有 <code>tsconfig.json</code></p></blockquote><p>👇 <code>src/index.ts</code> 编写箭头函数 (es6语法)</p><p>并且配置 <code>tsconfig.json</code> 中的 <code>&quot;target&quot;: &quot;es5&quot;</code> 为 <code>&quot;target&quot;: &quot;ESNEXT&quot;</code></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// es6 箭头函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">msg</span><span style="color:#89DDFF;">:</span><span style="color:#FFCB6B;">string</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">im a ts file</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// es5 const 常量声明</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">msg</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>👇 运行带参数指令 <code>tsc src/index.ts</code> 转译结果：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">msg</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">im a ts file</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ❌ 不是 ESNEXT 语法</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">msg</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>👇 运行不带参数指令 <code>tsc</code> 转译结果：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">use strict</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">msg</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">im a ts file</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// ✨ ESNEXT 语法</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">msg</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>👆 <code>&quot;use strict&quot;;</code> 严格模式 由 <code>&quot;alwaysStrict&quot;: true</code> 配置生效，一般不使用 <code>ts</code> 的转译功能，由 <code>现代前段构建工具</code> 处理是否输出严格模式</p><h2 id="lib相关lib-skiplibcheck" tabindex="-1">lib相关lib/skipLibCheck <a class="header-anchor" href="#lib相关lib-skiplibcheck" aria-label="Permalink to &quot;lib相关lib/skipLibCheck&quot;">​</a></h2><p>根据 <code>target</code> 的值 <code>lib</code> 有相应的默认值</p><p>因为该项与 <code>taget</code> 自动匹配，不用手动配置，手动配置一般出于优化 <strong>ts扫描性能</strong> 的目的</p><p>✨ <code>lib: [ &quot;[target].core.d.ts&quot; ]</code></p><blockquote><p><code>lib</code> 用于指定要包含在编译中的库文件，常用配置是： <code>[&quot;esnext&quot;, &quot;dom&quot;]</code>，手动配置可以减少一点默认配置带来的额外冗余损耗</p></blockquote><p>✨ <code>skipLibCheck</code> 我们看到 <code>tsc --init</code> 生成的 <a href="#tsc-init">默认配置</a> 中是开启这个的</p><p><a href="https://www.testim.io/blog/typescript-skiplibcheck/" target="_blank" rel="noreferrer">Understanding TypeScript’s skipLibCheck Once and For All</a></p><blockquote><p><code>skipLibCheck</code> 作用是：跳过 所有库文件(<code>d.ts</code>)的扫描检查(包括类型、语法检查)，即使<code>d.ts</code>中编写了非法语法也不报错</p></blockquote><p>👇 因此我们可以得出跳过的 <strong>好处</strong> 是：</p><ol><li>节省编译/静态扫描耗时</li><li>忽略第三方库 <code>d.ts</code>的错误导致项目无法启动</li><li>忽略第三方库使用不同版本的<code>typescript</code>编写的 <code>d.ts</code>，在项目<code>typescript</code> 版本下不兼容而导致的报错，项目无法启动</li></ol><p>👇 同时带来的 <strong>坏处/影响</strong> 是：</p><ol><li>第三方库or业务代码自己编写的 <code>d.ts</code>，没有错误提示，当编写了非法语法的内容时，在项目中体现为库文件不生效，但是需要手动排查是否语法问题or其他问题</li></ol><p><a href="https://cn.vitejs.dev/guide/features.html#typescript" target="_blank" rel="noreferrer">vite官方文档</a> 👇</p><blockquote><p>一些库（如：<code>vue</code>）不能很好地与 <code>&quot;isolatedModules&quot;: true</code> 共同工作</p><p>你可以在上游仓库(<code>vue</code>)修复好之前暂时使用 <code>&quot;skipLibCheck&quot;: true</code> 来缓解这个错误</p></blockquote><h2 id="types-typeroots" tabindex="-1">types/typeRoots <a class="header-anchor" href="#types-typeroots" aria-label="Permalink to &quot;types/typeRoots&quot;">​</a></h2><p>和 <code>lib</code> 相同，作用于 <code>ts</code> 使用哪些库文件：</p><ul><li><code>lib</code> 指定：内置库文件，默认根据 target 自动匹配 <code>vscode/node_modules/types</code></li><li><code>types/typeRoots</code> 指定第三方库文件，默认所有 <code>node_modules/@types/</code></li></ul><p>和手动配置 lib 同理，因为默认所有 <code>node_modules/@types/</code>，不用手动配置，手动配置一般出于优化 <strong>ts扫描性能</strong> 的目的</p><p>配置了 <code>types</code> ，代表仅安装 <code>@types</code> 不会生效，需要手动添加到了 <code>types</code> 中</p><p>如：<code>Vite</code> 的 配置了 <code>types: [&quot;node&quot;]</code>，安装 <code>@types/node</code></p><p>因为 <code>nodejs</code> 暴露 <code>api</code> 是使用 js编写的，为了获得其包的类型定义，需要安装名为 <code>@types/node</code> 的第三方包</p><h2 id="path相关rootdir-baseurl-paths" tabindex="-1">path相关rootDir/baseUrl/paths <a class="header-anchor" href="#path相关rootdir-baseurl-paths" aria-label="Permalink to &quot;path相关rootDir/baseUrl/paths&quot;">​</a></h2><ul><li><code>rootDir</code> - <code>tsconfig</code> 生效的目录</li><li><code>baseUrl</code> - 用于引入模块时省略编写路径（会让业务代码的路径不清晰）（建议用别名</li><li><code>paths</code> - <code>路径别名</code> 和 <code>webpack</code> 别名功能相同</li></ul><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">paths</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">@/*</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">src/*</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="js相关allowjs-checkjs" tabindex="-1">js相关allowJs/checkJs <a class="header-anchor" href="#js相关allowjs-checkjs" aria-label="Permalink to &quot;js相关allowJs/checkJs&quot;">​</a></h2><p><code>ts项目</code> 默认不支持识别 <code>js文件</code> ，而开启 <code>allowJs</code> 后，将允许 <code>ts</code> 和 <code>js</code> 混用</p><p>这适用于项目初期从 <code>js</code> 迁移到 <code>ts</code>，逐步迁移</p><blockquote><p>允许使用 <code>js</code> 的话，有个小注意事项，就是 <code>tsc</code> 编译，依然会对 <code>js</code> 做编译生成 <code>新的js</code></p><p>此时如果没有设置 <code>输出目录</code>，即输出目录为原文件位置，2个js将会 <code>同名同后缀</code> 而编译报错</p></blockquote><p>而开启 <code>checkJs</code> 后，<code>js</code> 内容将具有隐式(自动)类型定义，如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// VSCode 报红类型错误</span></span></code></pre></div><p>👆 <code>VSCode</code> 报红类型错误，并且执行 <code>tsc</code> 编译也将报错终止</p><p>在不开启 <code>checkJS</code> 时，因为 <code>js</code> 是<strong>弱类型语法</strong>，，这么赋值是合法的</p><p>因此有时我们会看到一些 <code>include</code> 配置 <code>[&#39;*.js&#39;]</code> ，确实是会让 <code>js</code> 具有一定的 <code>ts</code> 能力</p><h2 id="jsx" tabindex="-1">jsx <a class="header-anchor" href="#jsx" aria-label="Permalink to &quot;jsx&quot;">​</a></h2><p><a href="https://www.typescriptlang.org/tsconfig#jsx" target="_blank" rel="noreferrer">jsx -tsconfig 官方文档</a></p><ul><li><code>react</code>: Emit <code>.js</code> files with JSX changed to the equivalent React.createElement calls</li><li><code>react-jsx</code>: Emit <code>.js</code> files with the JSX changed to _jsx calls</li><li><code>react-jsxdev</code>: Emit <code>.js</code> files with the JSX changed to _jsx calls</li><li><code>preserve</code>: Emit <code>.jsx</code> files with the JSX unchanged</li><li><code>react-native</code>: Emit <code>.js</code> files with the JSX unchanged</li></ul><p>👆 这些模式只在代码生成阶段起作用，类型检查并不受影响</p><p>使用 <code>React17</code> 时，用 <code>react-jsx/react-jsxdev</code> 即可省略 <code>import React</code></p><p>同时留意是否需要升级 <code>typescript</code></p><h2 id="esmoduleinterop" tabindex="-1">esModuleInterop <a class="header-anchor" href="#esmoduleinterop" aria-label="Permalink to &quot;esModuleInterop&quot;">​</a></h2><p>允许 <code>import</code> 和 <code>commonjs</code> 混用，避免有些老旧的第三方库只有 <code>commonjs</code> 输出, 导致项目无法启动</p><p>我们看到 <code>tsc --init</code> 生成的 <a href="#tsc-init">默认配置</a> 中是开启这个的</p><h2 id="isolatedmodules" tabindex="-1">isolatedModules <a class="header-anchor" href="#isolatedmodules" aria-label="Permalink to &quot;isolatedModules&quot;">​</a></h2><blockquote><p>是否将每个文件作为单独的模块，即：不考虑每个文件的导入导出</p></blockquote><p>因为 <code>ts模块化</code> 包括 <code>变量空间</code> 和 <code>类型空间</code>，导入导出也是，因此 <code>tsc</code> 具有 <strong>全局分析</strong> 的能力，全局扫描后分析出需要导入的是类型还是变量</p><p>而在现代前端构建项目中，仅仅对 <code>ts</code> 做擦除处理，因此并不会有全局分析的过程，仅仅针对单个文件进行分析需要擦除的语法，此时若存在不清晰的导入导出，将会无法擦拭</p><p>如：</p><ul><li>从其它模块类型后未使用该类型</li><li>重导出(<code>expot { Type } from</code>)其它模块的类型</li><li>引入其它模块的<code>const enum</code>并使用</li><li>使用<code>namespace</code>语法</li></ul><p>因此在现代前端构建项目里，我们人为的让ts模块化的导入导出清晰起来，就是使用 <code>import type {}</code></p><p>让 转移器(擦除：<code>esbuild</code>) 不需要分析 <code>被导入文件</code> 内容是类型还是变量</p><p>而开启 <code>isolatedModules</code> 就可以让静态扫描 <code>IDE(VSCode)</code> 给出相应的提示。即：不开启此配置也可以，但是需要人为约定编程规范</p><p>所以 <code>Vite</code> 等仅擦除的工具会建议开启，而使用全局扫描的 <code>tsc</code> 时则无所谓</p><p><a href="https://juejin.cn/post/7053298681037979678" target="_blank" rel="noreferrer">理解Typescript配置项: isolateModules</a></p><ul><li><code>tsc</code> 的类型分析是项目级(全局分析)的，因此比起其它单文件分析类型的编译器，它能比其它的知道更多类型信息，因此对于非模块隔离的代码也能灵活处理</li><li>项目级的类型分析比单文件的类型分析更加强大，但代价就是它的运行速度会比单文件分析更慢。</li><li>如果使用 <code>ts-loader</code>, 它会用<code>tsc</code>分析整个项目。然而当它的 <code>transpileOnly</code> 选项为 <code>true</code> 时，它也将降级为仅对当前文件进行分析，此时也必须要求模块的隔离性，请启用 <code>isolateModules</code></li></ul><h2 id="noemit" tabindex="-1">noEmit <a class="header-anchor" href="#noemit" aria-label="Permalink to &quot;noEmit&quot;">​</a></h2><p>不输出转译结果，现代前端项目，把静态类型扫描交给 IDE 处理，但是当需要在提交代码前hook 执行命令扫描时，需要使用到 <code>tsc指令</code></p><p>此时 配置 <code>noEmit</code> 相当于仅执行类型扫描，不执行转译</p><p>与项目 <code>dev</code> 和 <code>build</code> 过程都独立，不影响项目编译性能</p><h2 id="格式相关" tabindex="-1">格式相关 <a class="header-anchor" href="#格式相关" aria-label="Permalink to &quot;格式相关&quot;">​</a></h2><table><thead><tr><th>_</th><th>_</th></tr></thead><tbody><tr><td>noImplicitAny</td><td>不允许隐式的<code>any</code>，默认<code>false</code>（允许）</td></tr><tr><td>noFallthroughCasesInSwitch</td><td>检查<code>switch</code>语句包含正确的<code>break</code></td></tr><tr><td>noImplicitReturns</td><td>不允许隐式的<code>return</code>，设为<code>true</code>后，如果函数没有返回值则会提示</td></tr><tr><td>noUnusedLocals</td><td>检查有没有未使用的局部变量</td></tr><tr><td>strictNullChecks</td><td>检查空值，检查有可能为<code>null</code>的地方，对象链式调用确保不会是<code>null</code></td></tr></tbody></table><p>👆 和 <code>eslint</code> 作用有点重合</p><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><table><thead><tr><th>_</th><th>_</th></tr></thead><tbody><tr><td>removeComments</td><td>将编译后的文件中的注释删掉，设为true即删掉注释</td></tr><tr><td>sourceMap</td><td>生成 <code>sourceMap</code> 文件，这个文件里保存的，是转换后代码的位置，和对应的转换前的位置。有了它，出错的时候，通过断点工具可以直接显示原始代码，而不是转换后的代码(识别并使用<code>.map</code>文件的是浏览器)</td></tr><tr><td>alwaysStrice</td><td>编译后的文件是否开启严格模式</td></tr><tr><td>module</td><td>编译结果使用的模块化标准: <code>None, CommonJS, AMD, System, UMD, ES6/ES2015, ES2020, ESNext</code></td></tr><tr><td>resolveJsonModule</td><td>支持引入json，但是必须把编译后module设置为commonjs</td></tr><tr><td>noResolve</td><td>不自动导入第三方类型如: <code>import $ from &#39;jquery&#39;</code>将可以使用<code>jquery库</code>，但是没有语法提示，可能在明确没有错误的场景编译时使用(但是这样就不要用ts不就好了...)</td></tr></tbody></table><p>👆 <code>module</code> - 和 <code>target</code> 转译js语法同理，<code>现代前段构建工具</code> 转译处理模块化语法，不需要 <code>ts</code> 的转译功能</p><p>👆 <code>resolveJsonModule</code> 同理，不需要 <code>ts</code> 的转译能力，而是开启识别非ts的文件即可👇</p><p>使用 <code>.d.ts</code> 库声明文件</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">module</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">*.css</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">declare</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">module</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">*.json</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p><code>declare module</code> 声明语法，一般是创建 <code>env.d.ts</code></p>`,148),p=[l];function t(c,r,d,i,D,y){return o(),e("div",null,p)}const u=s(a,[["render",t]]);export{C as __pageData,u as default};
