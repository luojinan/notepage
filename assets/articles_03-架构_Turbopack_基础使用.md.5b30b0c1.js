import{_ as e,o,c,V as t}from"./chunks/framework.b450deef.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/03-架构/Turbopack/基础使用.md","filePath":"articles/03-架构/Turbopack/基础使用.md"}'),d={name:"articles/03-架构/Turbopack/基础使用.md"},a=t("<ul><li>增量计算 <code>incremental computation</code> (在 <code>Turborepo</code> 上已经应用)</li><li>函数级别的缓存 <code>Function-level caching</code></li></ul><p>要解决 <code>Webpack</code> 大型应用构建慢的问题, 着手点都是希望：</p><ul><li>运行时来决定按需编译</li><li>修改文件 <code>HMR</code> 编译维度最小化 (<code>Vite</code>把工作交给浏览器基于 <code>ESM</code>)</li><li>编译产物缓存/更新</li><li>使用 <code>Rust</code> 语言工具替换 <code>js</code> 语言工具 - 如 <code>SWC</code> 替代 <code>babel</code> 做转译工作</li><li>插件生态</li></ul><blockquote><p>Turbopack is an incremental bundler optimized for JavaScript and TypeScript, written in <code>Rust</code>.</p><p>Turbopack 是增量的高性能的打包 JavaScript 和 TypeScript 打包器, 用 Rust 编写的</p></blockquote><blockquote><p>Turbopack is so fast because it’s built on a <code>reusable library for Rust</code> which enables <code>incremental computation</code> known as the Turbo engine</p><p>快的原因是使用 可重复利用的Rust库, 这个库至此 Turbo引擎 所谓的 增量计算</p></blockquote><p>函数级别缓存 <code>Vite</code> 基于 <code>ESM</code> 实现文件级别缓存(HMR不需要重新编译)</p><p><code>Turbopack</code> 通过 <code>Rust</code> 编译时实现文件级别缓存, 和运行时原理差不多, 只不过 <code>Turbopack</code> 要自己实现文件级别编译时缓存 👆 但是这是文件级别的吧？难道编译时还给文件内部的函数做缓存和HMR？🤯</p><p>因为是只有转译工具基于有点熟悉的 <code>SWC</code>, 打包工具没有用 <code>esbuild</code> 也就是其他部分都是自己编写的 <code>Rust</code></p>",8),i=[a];function r(l,p,s,n,u,_){return o(),c("div",null,i)}const k=e(d,[["render",r]]);export{T as __pageData,k as default};
