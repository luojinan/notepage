import{_ as s,o as a,c as o,V as n}from"./chunks/framework.b450deef.js";const d=JSON.parse('{"title":"queueMicrotask","description":"","frontmatter":{},"headers":[],"relativePath":"articles/01-深度学习/js/queueMicrotask.md","filePath":"articles/01-深度学习/js/queueMicrotask.md"}'),l={name:"articles/01-深度学习/js/queueMicrotask.md"},e=n(`<h1 id="queuemicrotask" tabindex="-1">queueMicrotask <a class="header-anchor" href="#queuemicrotask" aria-label="Permalink to &quot;queueMicrotask&quot;">​</a></h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noreferrer">Using microtasks in JavaScript with queueMicrotask() - MDN</a></p><h2 id="js的微任务" tabindex="-1">js的微任务 <a class="header-anchor" href="#js的微任务" aria-label="Permalink to &quot;js的微任务&quot;">​</a></h2><p>Browser</p><ul><li>MutationObserver</li><li>Promise.then catch finally</li><li>queueMicrotask</li></ul><p>Nodejs</p><ul><li>process.nextTick</li></ul><h2 id="queuemicrotask的背景" tabindex="-1">queueMicrotask的背景 <a class="header-anchor" href="#queuemicrotask的背景" aria-label="Permalink to &quot;queueMicrotask的背景&quot;">​</a></h2><p>虽然在过去要入列微任务有可用的技巧（比如创建一个立即 <code>resolve</code> 的 <code>promise）</code></p><p>但新加入的 <code>queueMicrotask()</code> 方法增加了一种标准的方式，可以安全的引入微任务而避免使用额外的技巧</p><p>Promise 的问题：</p><ul><li>当使用 <code>promise</code> 创建微任务时，由回调抛出的异常被报告为 <code>rejected promises</code> 而不是标准异常 <code>UnhandledPromiseRejectionWarning</code></li><li>创建和销毁 <code>promise</code> 带来了事件和内存方面的额外开销，这是正确入列微任务的函数应该避免的</li></ul><p>提供更底层的 <code>API</code> 而不是让大家 <code>hask</code> 其他方式实现是浏览器完善的趋势</p><h2 id="🌰-使用" tabindex="-1">🌰 使用 <a class="header-anchor" href="#🌰-使用" aria-label="Permalink to &quot;🌰 使用&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">MyElement</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">loadData</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">url</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">_cache</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">url</span><span style="color:#F07178;">]) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">queueMicrotask</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">_setData</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">_cache</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">url</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">dispatchEvent</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Event</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">load</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">fetch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">url</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">res</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">res</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">arrayBuffer</span><span style="color:#F07178;">())</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">data</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">_cache</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">url</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">data</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">_setData</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">data</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">dispatchEvent</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Event</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">load</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>👆 假如不使用 <code>queueMicrotask</code> , 在调用 <code>loadData()</code> 会出现2种情况，一种是异步一种是同步，调用行为变成不确定的了</p><p>此时给同步情况包裹 <code>queueMicrotask</code> 就可以跟 <code>fetch</code> 行为一致了，<code>Promise</code> 同理</p><blockquote><p>警告： 因为微任务自身可以入列更多的微任务，且事件循环会持续处理微任务直至队列为空，那么就存在一种使得事件循环无尽处理微任务的真实风险。如何处理递归增加微任务是要谨慎而行的。</p></blockquote><p>“实现一个 Promise” 在实现时也许可以采用 <code>queueMicrotask()</code></p>`,19),p=[e];function t(c,r,F,y,i,D){return a(),o("div",null,p)}const A=s(l,[["render",t]]);export{d as __pageData,A as default};
