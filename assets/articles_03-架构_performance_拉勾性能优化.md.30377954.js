import{_ as a,o as e,c as r,V as t}from"./chunks/framework.b450deef.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/03-架构/performance/拉勾性能优化.md","filePath":"articles/03-架构/performance/拉勾性能优化.md"}'),o={name:"articles/03-架构/performance/拉勾性能优化.md"},l=t('<p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=638#/sale" target="_blank" rel="noreferrer">前端性能优化方法与实战-拉勾</a></p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220926114935.png" alt=""></p><p>需要区分 白屏 和 首屏 吗？</p><p>网络层性能优化</p><ul><li>DNS</li><li>TCP并发-多域名方案/http3</li><li>HTTP缓存</li><li>serviceWorker缓存</li><li>sessionStorage缓存</li><li>Gzip压缩</li><li>拥塞预防</li><li>负载均衡</li><li>慢启动</li></ul><p>布局性能优化 图片加载或接口加载再撑开页面布局的方式，除了效果不好，还会带来重新计算布局的损耗</p><ul><li>GPU绘图</li><li>GUI和LCD</li><li>解析算法、标记化算法、树构建算法</li></ul><h2 id="埋点方法" tabindex="-1">埋点方法 <a class="header-anchor" href="#埋点方法" aria-label="Permalink to &quot;埋点方法&quot;">​</a></h2><blockquote><p>我们常见的埋点是业务逻辑的埋点，如展开选项，弹出广告等 还有一种埋点是页面元素显示的埋点，如按钮显示时埋点</p></blockquote><h3 id="手动埋点" tabindex="-1">手动埋点 <a class="header-anchor" href="#手动埋点" aria-label="Permalink to &quot;手动埋点&quot;">​</a></h3><p>优点：灵活，精细 缺点：麻烦，容易埋错，后期变动需要维护</p><h3 id="自动埋点" tabindex="-1">自动埋点 <a class="header-anchor" href="#自动埋点" aria-label="Permalink to &quot;自动埋点&quot;">​</a></h3><p>优点：简单，统一 缺点：不精细，难定制化</p><h4 id="服务端渲染-ssr" tabindex="-1">服务端渲染 SSR <a class="header-anchor" href="#服务端渲染-ssr" aria-label="Permalink to &quot;服务端渲染 SSR&quot;">​</a></h4><blockquote><p>当资源文件加载完，页面就渲染好了，首屏页面不需要再异步请求数据，因此直接判断资源加载停止时的时间 js提供的 Performance API 接口</p></blockquote><p>首屏时间 = DOMContentLoaded = domContentLoadedEventEnd - fetchStart</p><h4 id="spa" tabindex="-1">SPA <a class="header-anchor" href="#spa" aria-label="Permalink to &quot;SPA&quot;">​</a></h4><blockquote><p>资源加载完成只是模版资源，再通过js操作dom渲染页面才是首屏出来的时间</p></blockquote><ul><li>方法一 - 框架层面给组件生命周期mounted中埋点，最后一个mounted触发时间即首屏时间</li><li>方法二 - <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noreferrer">MutationObserver</a> 监控DOM元素，当DOM元素变化，标记变化的元素，记录时间点和分数，通过算法和dom权重计算出分数</li></ul><p>算法 TODO:</p><p>图片和DOM时分开的，有DOM没图检测不到 用js计算图片加载时间</p><p>js计算方法 TODO:</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>手动和自动都要用上，这样的数据采集放到管理系统里分析数据</p><h2 id="白屏时间" tabindex="-1">白屏时间 <a class="header-anchor" href="#白屏时间" aria-label="Permalink to &quot;白屏时间&quot;">​</a></h2><p>采集网络请求点</p><h2 id="工具使用" tabindex="-1">工具使用 <a class="header-anchor" href="#工具使用" aria-label="Permalink to &quot;工具使用&quot;">​</a></h2><h2 id="平台搭建-埋点" tabindex="-1">平台搭建(埋点) <a class="header-anchor" href="#平台搭建-埋点" aria-label="Permalink to &quot;平台搭建(埋点)&quot;">​</a></h2>',28),i=[l];function n(s,c,h,p,d,u){return e(),r("div",null,i)}const b=a(o,[["render",n]]);export{m as __pageData,b as default};
