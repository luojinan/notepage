import{_ as e,o as l,c as i,V as o}from"./chunks/framework.b450deef.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/其他/week/缓存工具方法思路.md","filePath":"articles/其他/week/缓存工具方法思路.md"}'),t={name:"articles/其他/week/缓存工具方法思路.md"},a=o('<p>目的：缓存需要频繁计算的结果,包括异步计算</p><p>从目的上看，有点像vue的计算属性具有缓存性质(不能异步)，也像vuex状态仓库缓存结果</p><p>实现：</p><ul><li>利用高阶函数,开辟出一个作用域存放<code>计算结果</code>和<code>执行结束回调事件队列</code>。实现多个地方调用，作用域相当于全局变量，可以多个地方调用</li><li><code>回调函数</code>的执行，不是简单的执行结束之后调用传入的回调函数，而是先把回调函数存到相应key的事件队列中，异步结束遍历执行回调事件队列。即可做到，异步未结束时，再调一次相同的异步计算，会把第二次的回调函数加入队列，在异步结束时全部执行</li><li>异步执行结束，遍历执行回调事件队列之后要删除相应key的事件队列</li></ul><p>拓展：</p><ul><li>开辟出来的作用域，只要仍有一个地方调用着，都不会被回收(所有全局变量方案的情况)。因此存在内存泄漏的风险，可以尝试，按时间新旧清除<code>计算结果</code>(占内存的主要是结果数据而不是回调函数)</li></ul><h3 id="跟我现在的全局变量方案有什么不同" tabindex="-1">跟我现在的全局变量方案有什么不同？ <a class="header-anchor" href="#跟我现在的全局变量方案有什么不同" aria-label="Permalink to &quot;跟我现在的全局变量方案有什么不同？&quot;">​</a></h3><p>我的设计方案是：</p><ul><li>利用es6的class类，开辟出作用域存放<code>计算结果</code></li><li>利用promise，不需要传递回调函数进来执行而是交由调用方编写(更符合人脑思维)</li><li>但是确实没有考虑异步未结束重复就调用的情况，目前会重复调用，并且计算结果相互覆盖(数据是相同的)</li></ul><p>假如让我考虑异步未结束情况，我也不会通过回调队列延后执行相同异步场景 而是让<code>计算结果</code>有标识</p><ul><li>异步开始时就给全局变量<code>计算结果</code>中创建key，赋值pending状态的promise，异步未结束就重复请求时，因为key有值，将会返回出promise，在调用方去await来使用</li></ul><p>因此值得借鉴的是</p><ul><li>队列、延后回调的使用</li><li>处理key的逻辑也由外部决定，多人项目还是不希望key放得太开，反而会有重复缓存</li></ul><p>计算属性原理也是这样吗？</p>',14),c=[a];function _(s,d,p,r,n,u){return l(),i("div",null,c)}const h=e(t,[["render",_]]);export{k as __pageData,h as default};
