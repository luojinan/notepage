import{_ as n,o as l,c as o,k as s,V as a}from"./chunks/framework.b450deef.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/01-深度学习/js/前端模块化.md","filePath":"articles/01-深度学习/js/前端模块化.md"}'),p={name:"articles/01-深度学习/js/前端模块化.md"},e=s("iframe",{src:"//player.bilibili.com/player.html?aid=208982494&bvid=BV1jh411t7eX&cid=435896955&page=1",width:"100%",height:"300px",scrolling:"no",border:"0",frameborder:"no",framespacing:"0",allowfullscreen:"true"}," ",-1),t=a(`<p>完整视频系列及倍数请移步 <a href="https://space.bilibili.com/100023688" target="_blank" rel="noreferrer">bilibili</a></p><h2 id="模块化背景" tabindex="-1">模块化背景 <a class="header-anchor" href="#模块化背景" aria-label="Permalink to &quot;模块化背景&quot;">​</a></h2><blockquote><p>在现代前端工程里面，我们离不开打包工具，比如说 <a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noreferrer">webpack</a>、<a href="https://www.rollupjs.com/" target="_blank" rel="noreferrer">rollup</a>、<a href="https://cn.vitejs.dev/guide/" target="_blank" rel="noreferrer">vite</a></p></blockquote><p>那么我们为什么要用到打包工具呢? 原因之一是：在浏览器支持 ES 模块之前，前端没有原生支持以模块化的方式开发 js。打包工具的出现也是为了帮助开发让浏览器支持的模块化方案。</p><p>那不使用模块化开发的体验会是什么样子呢？</p><ul><li>容易造成变量污染(无意声明相同变量造成使用时不是预期变量)</li><li>js文件之间有依赖关系时，因为不能在js中引js，只能统一写到script引入，需要注意顺序问题。而且被依赖的js一般不希望被其他js调用，script只能全局引入，所有js都能调用不需要引用</li><li>开发无法分块编写，将项目分成更小的独立部分，是跟优雅的开发模式，更好维护代码和更好的复用。</li></ul><p>这也是<code>“打包”</code>这个概念出现的原因：使用打包工具抓取收集依赖资源、处理成script或是其他形式链接资源文件到引用方文件中，实现模块化。</p><blockquote><p>接下来将主要讲解 <code>Commonjs、ES Module</code> 模块化并且不会讲基础使用，其他如 <code>AMD、UMD</code> 可能提及但不会细讲，感兴趣请自行搜索🔍学习</p></blockquote><h2 id="模块化方案环境支持" tabindex="-1">模块化方案环境支持 <a class="header-anchor" href="#模块化方案环境支持" aria-label="Permalink to &quot;模块化方案环境支持&quot;">​</a></h2><p>开发环境（<code>nodejs</code>）</p><ul><li>支持<code>Commonjs</code></li><li>ES6后通过<code>.mjs</code>支持 <code>ES Module</code></li></ul><p>浏览器环境</p><ul><li>不支持 <code>Commonjs</code></li><li>ES6后支持 <code>ES Module</code></li></ul><h2 id="commonjs" tabindex="-1">CommonJs <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;CommonJs&quot;">​</a></h2><blockquote><p>Commonjs是一种模块化规范(思想)</p></blockquote><p><code>Commonjs</code> 是一种规范并不是一种具体的代码，类似 <code>promise A+</code> 规范，只要符合规范里所有的条件，那它就是 <code>Commonjs</code>。</p><p>而nodejs就是借鉴这种思想实现自己的模块化的，所以也不能完全说nodejs就是 <code>Commonjs</code></p><blockquote><p>AMD模块化同样脱胎于Commonjs规范，浏览器支持的Commonjs一般是使用require.js的库，注意这个库和nodejs的require不是一个东西，这个库的Commonjs是AMD实现的。</p></blockquote><p>为了解决变量污染的问题，Commonjs规定每一个js都是独立的模块，即依赖的文件没有抛出的变量，是无法获到的。可以看作每个文件都是一个闭包。</p><blockquote><p>另外，<code>webpack</code>作为以nodejs为底层语言(强调这个是因为<a href="https://esbuild.github.io/" target="_blank" rel="noreferrer">ESbuild</a>以<a href="https://www.topgoer.com/" target="_blank" rel="noreferrer">GO</a>为底层语言)的打包工具，是依靠nodejs的Commonjs做依赖收集进行整合后用方法插入script来协助打包的。所以webpack工程下，编写Commonjs不需要额外支持，可以直接编译识别。-- TODO: 这里补一个文章跳转各种打包工具的模块化原理</p></blockquote><h3 id="从0实现简易commonjs" tabindex="-1">从0实现简易Commonjs <a class="header-anchor" href="#从0实现简易commonjs" aria-label="Permalink to &quot;从0实现简易Commonjs&quot;">​</a></h3><h4 id="_0-前期准备" tabindex="-1">0. 前期准备 <a class="header-anchor" href="#_0-前期准备" aria-label="Permalink to &quot;0. 前期准备&quot;">​</a></h4><p>开始前先转变以前的固有印象，<code>“引入”</code>和<code>“抛出”</code></p><p>在Commonjs</p><ul><li><code>引入</code>的本质是存储/缓存</li><li><code>抛出</code>的本质是读取缓存</li></ul><p>实现模块化的本质就是，把每个文件存储到<code>Modules</code>的大对象中，每个文件就是一个子对象<code>module</code>，且每个文件<code>module对象</code>内有各种信息</p><p>打印module和Module</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Module </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">[</span><span style="color:#89DDFF;">module</span><span style="color:#F07178;">] = {</span></span>
<span class="line"><span style="color:#F07178;">    id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">exports</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">loaded</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">module</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  ...</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span></code></pre></div><p>抛出的内容就是往对象里的<code>exports</code>存储深拷贝的值，引入就是获取整个<code>exports</code>（一般解构赋值取出来使用）</p><p>由此可以看出一个 <code>Commonjs</code> 的特性：引入(也就是获取缓存)的值取决于当时存储时的值，也就不是动态可变的了</p><h4 id="_1-让js文件直接支持myexport、myrequire等" tabindex="-1">1. 让js文件直接支持myexport、myrequire等 <a class="header-anchor" href="#_1-让js文件直接支持myexport、myrequire等" aria-label="Permalink to &quot;1. 让js文件直接支持myexport、myrequire等&quot;">​</a></h4><p>支持Commonjs的环境(nodejs)，会在编译运行js时(运行 <code>node xx.js</code> )包装js</p><p>即我们写的js不是最终执行的js，而是会被包裹起来，进行统一处理</p><p>如 <code>node index.js</code> ，执行index.js，nodejs就会先对index.js进行包装</p><p>注入进去<code>export、models</code>等变量或函数</p><p>这就是在js里全局支持使用export的原因</p><p>接下来手写实现一个 <code>Commonjs</code>模块化，不会使用nodejs模块化相关的api，但是还是需要用到nodejs其他的api来帮助我们实现，如读取文件内容的 <code>fs</code>，遇到不会的<a href="http://nodejs.cn/api/" target="_blank" rel="noreferrer">nodejs API</a>请自行搜索🔍学习</p><p>由👆分析，我们需要读取require引入的资源文件内容，进行包装并且注入模块化api或其他工具方法</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 包装js文件 注入api的期望方式</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 柯里化函数方式，第一次调用传递引入的资源文件内容，返回一个函数，传递要注入的东西并运行</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>👆包装js文件 注入api的期望方式</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">wrap</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">fileContent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 拼接函数进行包装 注意要包一层()才不会被eval立即执行,而是返回一个字符串()内的函数</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newfileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">(function (myrequire){</span></span>
<span class="line"><span style="color:#C3E88D;">    </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C3E88D;">  })</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">eval</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newfileContent</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>👆 资源文件内容是一个js文件的所有字符串，里面可以直接使用模块化api 先包装字符串，然后执行，注意执行字符串的结果要返回一个函数而不是直接执行(会报错myrequire undefined)</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">requuire</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">fs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myrequire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">开始引入</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFile</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">没有找到引用资源</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">myrequire</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./index.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>这样就能运行引入的资源文件了，但是还没实现模块化抛出和接收的动作</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// index.js</span></span>
<span class="line"><span style="color:#82AAFF;">myrequire</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#82AAFF;">myrequire</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./b.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">lof</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">执行index.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// b.js</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">执行b.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 没有a.js</span></span></code></pre></div><p>打印内容会发现执行顺序</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">开始引入index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">执行index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">开始引入a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">开始引入b</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">没有找到a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">执行b</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span></code></pre></div><p>可以看到，index.js引入a和b，执行index并没有等a和b引入结束</p><p>而运行一次原生Commonjs如下</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">开始引入index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">开始引入a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">error 没有找到a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span></code></pre></div><p>原生是会等a和b引入结束才执行index的，并且遇到引入异常会中断运行</p><blockquote><p><code>Commonjs</code> 模块化是同步加载的</p></blockquote><p>我们自己写的 <code>Commonjs</code> 不是同步的原因是fs读取文件内容的api <code>fs.readFile()</code> 用了异步加载</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 读取文件内容是异步的，外面调用myrequire是不会等内部异步结束</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 所以读取文件内容要用同步</span></span>
<span class="line"><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFile</span><span style="color:#A6ACCD;">(filePath)</span></span>
<span class="line"><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFileSync</span><span style="color:#A6ACCD;">(filePath)</span></span></code></pre></div><p>并且处理读取文件内容失败，要中断nodejs运行，抛出错误<code>throw</code> 改造后的 <code>myrequire()</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myrequire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">开始引入</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFileSync</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">没有找到引用资源</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_2-myrequire识别资源方式" tabindex="-1">2. myrequire识别资源方式 <a class="header-anchor" href="#_2-myrequire识别资源方式" aria-label="Permalink to &quot;2. myrequire识别资源方式&quot;">​</a></h4><p>识别资源路径的几种格式</p><ul><li>xxx node内置模块</li><li>/xxx 当前目录绝对路径</li><li>./ ../ 当前目录相对路径</li><li>xxx node_modules下的目录</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * 文件路径几种格式</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * xxx node内置模块</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * /xxx 当前目录绝对路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * ./ ../ 当前目录相对路径</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * xxx node_modules下的目录</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> enterPublicPath </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">example</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">dealFilePath</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">firstString</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">charAt</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 路径首字符</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">firstString</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 当前目录相对路径转为绝对路径(模拟的都是从example中引入的，跟当前core文件夹是同级所以相对路径也是)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// console.log(&#39;当前文件core的绝对路径&#39;,__dirname);</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">__dirname</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">../</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">enterPublicPath</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">}\`</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">firstString</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 当前目录绝对路径</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">node内置模块</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// node内置模块</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// node_module模块</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>👆这里仿照webpack定义一个 <code>publicPath</code>，用于处理相对路径时的公共路径前缀，配合我们把代码抽离到core文件夹和在expample文件夹运行</p><p>关于资源路径属于 <code>node_module</code>的情况，会逐级查找资源，如下规则，这里不做实现</p><ul><li>在当前目录下的 node_modules 目录查找。</li><li>如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查找。</li><li>沿着路径向上递归，直到根目录下的 node_modules 目录。</li><li>在查找到第三方模块后，会找 <code>package.json</code> 下 main 属性指向的文件，如果没有 <code>package.json</code> ，在 nodejs 环境下会依次查找 <code>index.js ，index.json ，index.node</code>。</li></ul><p>改造后 <code>myrequire()</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myrequire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">开始引入</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">dealFilePath</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// 处理资源路径</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileContent</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFileSync</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">没有找到引用资源</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_3-require处理资源防止套娃引用" tabindex="-1">3. require处理资源防止套娃引用 <a class="header-anchor" href="#_3-require处理资源防止套娃引用" aria-label="Permalink to &quot;3. require处理资源防止套娃引用&quot;">​</a></h4><p>reuqire顺序是深度优先遍历</p><blockquote><p>这里的深度优先并不是模块化工具在做递归，而是资源引用的写法：每次在不同文件下<code>require</code>，因为是同步执行自然而然形成的嵌套调用</p></blockquote><p>index引用a、b，a文件引用b，b文件引用a，node原生Commonjs执行顺序</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">开始引入index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">开始引入a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js </span></span>
<span class="line"><span style="color:#A6ACCD;">开始引入b</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">js</span><span style="color:#A6ACCD;"> (b有引a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">但是不会触发开始引入和执行a)</span></span>
<span class="line"><span style="color:#A6ACCD;">执行b</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">执行a</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span>
<span class="line"><span style="color:#A6ACCD;">执行index</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">js</span></span></code></pre></div><p>可以看出不会重复引用</p><p>实现原理：和递归遍历类似，可以用一个weakmap或者一个变量存储调用过的资源文件，因为做引入抛出也是存储的时候要用到Modules的变量，所以直接用一个Modules存储引用过的文件,把资源路径作为数组id存储</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Modules </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 做全局变量</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cacheModule</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">some</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      id</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>改造后 <code>myrequire()</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myrequire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">开始引入</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">dealFilePath</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">cacheModule</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 判断是否加载过</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 加载过不再重复加载</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileContent</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFileSync</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">没有找到引用资源</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_4-引用和抛出变量" tabindex="-1">4. 引用和抛出变量 <a class="header-anchor" href="#_4-引用和抛出变量" aria-label="Permalink to &quot;4. 引用和抛出变量&quot;">​</a></h4><p>抛出和接收是使用模块化编程时的直观感受 实际上“抛出”的动作是文件把值存到export里 而“接收”就是require去export对象中取值(require还有抓取、包装文件内容的作用) 前面提到引用和抛出的本质是存储和获取，且每次加载资源都有一个数组存储资源的信息，我们往Modules全局变量中存储相应要抛出的变量即可</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Modules </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cacheModule</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">some</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      id</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">      exports</span><span style="color:#89DDFF;">:{}</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 加一个存储变量的地方</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>原生nodejs的Commonjs的使用方法是：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">exports.</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;&#39;</span></span></code></pre></div><p>👆这里两种存储变量的形式，本质都是往全局变量Modules里的exports进行存储，因此两者使用的区别，请在实现之后自行思考，本质区别就是操作对象赋值的区别而已</p><p>我们往js里注入方法的时候只注入了myrequire，这次再往里注入module和exports</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// myrequire() 的注入变量代码片段</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> index </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">findIndex</span><span style="color:#A6ACCD;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">newPath)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 注入多两个变量 module 和 exports</span></span>
<span class="line"><span style="color:#82AAFF;">wrap</span><span style="color:#A6ACCD;">(fileContent)(myrequire</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">Modules[index]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">Modules[index]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">exports)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>👆这样我们实现了资源文件的存储变量，接下来要实现获取存储的变量，也就是在<code>myrequire()</code>之后返回出资源存储的整个对象exports即可</p><p>改造后 <code>myrequire()</code></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">myrequire</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">filePath</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">开始引入</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">dealFilePath</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">cacheModule</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">isExist</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">readFileSync</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">utf8</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#89DDFF;font-style:italic;">catch</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">err</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">throw</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`</span><span style="color:#C3E88D;">没有找到引用资源</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">newPath</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 注入 存储用的两个变量 module 和 exports</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Modules</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">findIndex</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">item</span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;">item</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">id</span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;">newPath</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">wrap</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">fileContent</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">myrequire</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">Modules</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">Modules</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">exports</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 返回资源文件存储的变量exports</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Modules</span><span style="color:#F07178;">[</span><span style="color:#A6ACCD;">index</span><span style="color:#F07178;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">exports</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_5-整理" tabindex="-1">5. 整理 <a class="header-anchor" href="#_5-整理" aria-label="Permalink to &quot;5. 整理&quot;">​</a></h4><p>至此，我们已经从0到1实现了一个简易版的 <code>Commonjs</code></p><p>并且由此可知几个<strong>Commonjs的特性：</strong></p><ul><li><strong>加载资源是同步加载的</strong>，即如果资源很大还是会阻塞后面资源的加载</li><li>资源套娃引用或重复引用，<strong>不会重复加载</strong></li><li><strong>exports抛出的变量是值的拷贝</strong>，取决于加载资源时进行存储的变量是什么，后续不会更新存储的变量(即抛出的值是静态的)</li><li>执行require，会加载<strong>资源存储的所有变量</strong>到本文件</li></ul><h3 id="commonjs获取动态值" tabindex="-1">Commonjs获取动态值 <a class="header-anchor" href="#commonjs获取动态值" aria-label="Permalink to &quot;Commonjs获取动态值&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// lib.js</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> counter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">changeCounter</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">counter</span><span style="color:#89DDFF;">++;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">getCounter</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">counter</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  changeCounter</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>这样就可以拿到深拷贝的值，因为并不是拿拷贝的值，而是通过函数作用域去取值，作用域内的值变了，取到值就变了。</p><h3 id="关于commonjs的require是动态引用" tabindex="-1">关于Commonjs的require是动态引用 <a class="header-anchor" href="#关于commonjs的require是动态引用" aria-label="Permalink to &quot;关于Commonjs的require是动态引用&quot;">​</a></h3><blockquote><p>Commonjs的<code>require()</code>发生在运行时 首先明确一点，动态的概念不等于异步的概念</p></blockquote><p>动态引用是在条件作用域里require，只有在调用该函数才会运行引用资源，运行时才去获取对应的内容</p><p>而动态引用分两种情况</p><ul><li>不需要执行就已知资源路径的情况</li><li>需要执行才知道资源路径的情况 如:</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 1.不需要执行就已知资源路径的情况</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#C792EA;">=&gt;</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 2.需要执行才知道资源路径的情况</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">x</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">filePath</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">require</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">onclick</span><span style="color:#89DDFF;">(){</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">a</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./a.js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>在webpack里require的资源是个未知的变量（运行时才可知）的话，上线之后会加载不到该文件。为什么nodejs可以加载，webpack不行？</p><blockquote><p>是因为在本地node环境下，动态require运行时可以找到文件，如果动态require的文件是本地不存在的话，也是会像webpack一样报错找不到的 而webpack打包不会运行未知的代码(会收集已知的require资源),所以不会知道动态require的文件是什么，就不会把目标文件打包进项目，最后运行时服务器中找不到该文件就会报错</p></blockquote><p>关于异步加载： 希望点击才加载a文件，在Commonjs里，index依赖a即使在条件作用域里，也必须初始化的时候就加载进来，点击时只是获取并执行a，并不是点击时才去找a文件进行加载和执行</p><h3 id="不用exports-xx-而是exports-xx-来存储变量会怎样" tabindex="-1">不用exports.xx=&#39;&#39; 而是exports={xx:&#39;&#39;} 来存储变量会怎样 <a class="header-anchor" href="#不用exports-xx-而是exports-xx-来存储变量会怎样" aria-label="Permalink to &quot;不用exports.xx=&#39;&#39; 而是exports={xx:&#39;&#39;} 来存储变量会怎样&quot;">​</a></h3><blockquote><p><code>module.exports = {}</code>、<code>exports.xx=&#39;&#39;</code> 同样是操作exports存储对象，那可不可以<code>exports = {}</code>呢？</p></blockquote><p>我们知道exports的来源是注入到函数里的形参 也就是👇的形式：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> exports </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">exports</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">exports</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">b</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">a</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">exports</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">exports</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// {a:&#39;a&#39;}</span></span></code></pre></div><p>👆函数的引用类型形参做重新赋值，在函数体中将会是个新的变量，而不是外部的变量 是js原生这么干的，不关nodejs的<code>Commonjs机制</code>的事</p><p>在require中，exports是文件资源信息对象里的一个属性，如果在文件中自己重新赋值了exports，因为一个文件就是一个单独的作用域函数，exports将是一个作用域下全新的变量，而不再是外部文件对象里的属性，那么require就取不到文件抛出的信息了</p>`,108),c=s("p",{xx:""},"这也就是为什么抛出数据只能exports.xx 一个个抛出(存储)而不能直接exports =",-1),r=a(`<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> module </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">myexports</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 传入的是module.myexports引用类型，如果重新赋值了myexports将不再有引用作用而是一个新的对象</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">a</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">myexports</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">myexports</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// --&gt;{ myexports: {a:&#39;1&#39;} }</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// myexports.b = &#39;b&#39; // --&gt;{ myexports: {b: &#39;b&#39;} }</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">a</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module.</span><span style="color:#A6ACCD;">myexports)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">module</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// --&gt;{ myexports: {a:&#39;1&#39;} }</span></span></code></pre></div><h2 id="es-module" tabindex="-1">ES Module <a class="header-anchor" href="#es-module" aria-label="Permalink to &quot;ES Module&quot;">​</a></h2><h3 id="node环境" tabindex="-1">node环境 <a class="header-anchor" href="#node环境" aria-label="Permalink to &quot;node环境&quot;">​</a></h3><p><code>node 8.5</code>开始支持mjs，但是还是实验性的所以需要参数<code>--experimental-modules</code> 执行.mjs 会提示ESM是实验性</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">node</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--experimental-modules</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">index.mjs</span></span>
<span class="line"><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">node:9076</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> ExperimentalWarning: The ESM module loader is experimental.</span></span></code></pre></div><p><code>node13</code>开始不需要实验参数,可以直接执行.mjs .mjs可以用ESM，并且还是支持原来Commonjs</p><h3 id="浏览器环境" tabindex="-1">浏览器环境 <a class="header-anchor" href="#浏览器环境" aria-label="Permalink to &quot;浏览器环境&quot;">​</a></h3><blockquote><p>和node环境用mjs后缀的方式不同，在浏览器环境不认识mjs，mjs是node自己新增的</p></blockquote><p>浏览器需要不影响以往的没有模块化的js，所以要支持模块化时在<code>&lt;srcipt&gt;</code>标签加上type</p><h4 id="script标签的async、defer" tabindex="-1">script标签的async、defer <a class="header-anchor" href="#script标签的async、defer" aria-label="Permalink to &quot;script标签的async、defer&quot;">​</a></h4><p>在讲<code>type=module</code>之前，我们看看其他属性 默认scipt标签都是同步加载，即按顺序加载script标签并会阻塞后面的加载 浏览器提供scipt识别为需要异步加载资源<code>async、defer、module</code>都是异步加载的</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./1.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">defer</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./2.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">async</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><ul><li><code>defer</code>要等到整个页面在内存中正常渲染结束（<code>DOM</code> 结构完全生成，以及其他脚本执行完成），才会执行(即使已经下载完成了)</li><li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再恢复渲染</li></ul><p>浏览器的V8引擎，渲染页面和执行js是共用一个线程的，所以会交错执行如👆<code>async</code>的场景。</p><p><code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</p><h4 id="type-module" tabindex="-1">type=module <a class="header-anchor" href="#type-module" aria-label="Permalink to &quot;type=module&quot;">​</a></h4><p>因为<code>type=&quot;module&quot;</code>默认就是异步加载的，所以也要有个异步规则，那就是<code>defer</code> 所以👇其实就是一种省略默认值的写法</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./1.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">&lt;!-- 等同于 --&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./1.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">defer</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>和<code>defer</code>基本相同，等页面渲染结束，才按顺序执行资源(即使已经下载完资源)</p><p>而如果是<code>async</code></p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./1.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">async</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>则会是一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再恢复渲染，并且不保证顺序</p><p>由👆<code>type=&quot;module&quot;</code>，更多的是让文件内部可以使用ESM模块化，控制异步规则还是靠<code>defer、async</code><code>ES Module</code>除了加载规则跟异步加载资源相同外，内部是支持直接使用import的。而这是只开启异步加载的资源文件无法做到的</p><h3 id="esm识别的资源路径" tabindex="-1">ESM识别的资源路径 <a class="header-anchor" href="#esm识别的资源路径" aria-label="Permalink to &quot;ESM识别的资源路径&quot;">​</a></h3><p>回忆一下 <code>Commonjs</code>识别资源的路径有<code>相对路径</code>、<code>绝对路径</code>、<code>nodejs内置模块</code>、<code>node_module第三方资源</code></p><p>那ESM的资源路径：<code>相对路径</code>、<code>绝对路径</code>、<code>第三方资源URl</code></p><p><code>import</code>第三方资源只能引用<code>完整的 URL</code>，相对以前的裸导入 (bare import specifiers)(人话就是直接通过模块名导入)，很不太方便，如下例:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> lodash </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">lodash</span><span style="color:#89DDFF;">&#39;</span></span></code></pre></div><p>它不同于 Node.JS 可以依赖系统文件系统，层层寻找 <code>node_modules</code></p><p>在 ESM 中，可通过 <code>importmap</code> 使得裸导入可正常工作:</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">importmap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  &quot;imports&quot;: {</span></span>
<span class="line"><span style="color:#A6ACCD;">    &quot;lodash&quot;: &quot;https://cdn.sykpack.dev/lodash&quot;,</span></span>
<span class="line"><span style="color:#A6ACCD;">    &quot;ms&quot;: &quot;https://cdn.sykpack.dev/ms&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lodash</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>加了上面的map，浏览器就支持通过别名直接引入模块了</p><p>补充一点：平时可以到这里 <a href="https://npm.devtool.tech/" target="_blank" rel="noreferrer">https://npm.devtool.tech/</a> 查看各种第三方包的cdn，看看别人的导出方式 👇浏览器的控制台可以直接使用ESM的CDN</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lodash </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">import</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">https://cdn.skypack.dev/lodash</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> lodash</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><h3 id="接收的是动态的值" tabindex="-1">接收的是动态的值 <a class="header-anchor" href="#接收的是动态的值" aria-label="Permalink to &quot;接收的是动态的值&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setTimeout</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">baz</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">500</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>上面代码输出变量 foo ，值为 bar ，500 毫秒之后变成 baz 。</p><p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新(如果是引用类型也不行，因为是运行时进行存储的值的拷贝)</p><h3 id="esm自动严格模式" tabindex="-1">ESM自动严格模式 <a class="header-anchor" href="#esm自动严格模式" aria-label="Permalink to &quot;ESM自动严格模式&quot;">​</a></h3><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;</code>;。</p><p>严格模式主要有以下限制:</p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ul><p>其中，尤其需要注意this的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用this。</p><p>👇因此利用顶层的 <code>this</code> 等于 <code>undefined</code> 这个语法点，可以侦测当前代码是否在 <code>ES6</code> 模块之中。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> isNotModuleScript </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">this</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">undefined;</span></span></code></pre></div><h2 id="编译时、运行时、静态化" tabindex="-1">编译时、运行时、静态化 <a class="header-anchor" href="#编译时、运行时、静态化" aria-label="Permalink to &quot;编译时、运行时、静态化&quot;">​</a></h2><ul><li>ESM发生在编译时且是静态化的</li><li>CJS发生在运行时</li></ul><p>编译时报错是语法/句法错误 运行时报错是各种情况 👆平时可以留意一下两种报错的区别</p><blockquote><p>ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及抛出和接收的变量</p></blockquote><h3 id="esm的编译时" tabindex="-1">ESM的编译时 <a class="header-anchor" href="#esm的编译时" aria-label="Permalink to &quot;ESM的编译时&quot;">​</a></h3><p>编译时：如 <code>import</code> 命令是编译阶段执行的，即在代码运行之前。 编译过程不能使用表达式和变量，表达式和变量是只有在运行时才能得到的动态结果</p><p><strong>因为ESM是命令式语法，因此不做源码解读和伪代码的编写，请彻底理解👇发生在编译时的模块化原理</strong></p><p>编译流程是：</p><blockquote><p>JS 引擎对脚本静态分析的时候，遇到命令 <code>import</code> ，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的文件里面去取值（由于 <code>ES6 import</code>的变量，只是一个<code>“符号连接(指针)”</code>，所以这个变量是只读的，相当于“抛出”的变量都是const，对它进行重新赋值会报错。</p></blockquote><blockquote><p>浏览器通过html的<code>&lt;script type=&quot;module&quot;&gt;</code>,加载第一个js，这个js是入口文件 后续模块都是js中的import，而不是浏览器中的<code>&lt;script&gt;</code></p></blockquote><blockquote><p>浏览器加载文件的功能我们称为加载器，加载器开始加载文件时，会把文件路径作为key记录到模块映射(缓存)中 不等文件加载完成，标记为加载中。继续开始下一个文件。 加载完成后触发解析文件即<code>编译</code>，识别静态语法中import。继续触发加载器，以此形成了一种深度遍历的效果，不过是不等待的那种 有了模块映射(缓存)，加载器就可以跳过加载重复模块，直接导出模块的运行结果 另外，导出值的引用是在递归加载文件之后执行的，即会到最深层再往上抛出的顺序导出值的引用</p></blockquote><p>ES6 模块“抛出”的变量是活的，ES6 模块是动态取值，并不是通过存储值来做抛出</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">fs</span><span style="color:#89DDFF;">&#39;\`</span></span></code></pre></div><p>👆不是函数，是js语法支持的读取命令，且命令实现只读取fs文件中抛出的a和b，并且这里的<code>{ }</code>并不是解构赋值，而是命令解析的字符串。</p><p>另外<code>import</code> 不能写在条件代码块之中，没法做静态优化了，违背了 ES6 模块的设计初衷</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 报错</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (x </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">MyModual</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">./myModual</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>编译过程处理 import 语句，这时不会去分析或执行 if 语句，所以 import 语句放在 if 代码块之中毫无意义，报句法错误，而不是执行时错误</p><h3 id="cjs的运行时" tabindex="-1">CJS的运行时 <a class="header-anchor" href="#cjs的运行时" aria-label="Permalink to &quot;CJS的运行时&quot;">​</a></h3><p><code>CommonJS</code> 和 <code>AMD</code> 模块化，都只能在运行时确定模块的依赖关系，以及抛出和接收的变量 如Commonjs</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">fs</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">\`</span></span></code></pre></div><p>上面讲原理的时候也讲到，<code>rqeuire</code>是个函数，是运行函数才能读取资源的，并且只能整个文件的存储都读取下来，再解构赋值给a和b</p><h3 id="nodejs中共用两种模块化方式会怎样" tabindex="-1">nodejs中共用两种模块化方式会怎样 <a class="header-anchor" href="#nodejs中共用两种模块化方式会怎样" aria-label="Permalink to &quot;nodejs中共用两种模块化方式会怎样&quot;">​</a></h3><p>通过 Babel 转码，CommonJS 模块的 require 命令和 ES6 模块的 import 命令，可以写在同一个文件里面，但是最好不要这样做。因为import 在静态解析阶段执行，所以它是一个模块之中最早执行的，出现不按代码顺序执行的情况：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">core-js/modules/es6.symbol</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">core-js/modules/es6.promise</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">React</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p><code>core-js/modules</code>是给react实例化用的插件，需要在react之前加载好，但是这样写会先实例化react</p><h2 id="esm可以运行时的import" tabindex="-1">ESM可以运行时的import() <a class="header-anchor" href="#esm可以运行时的import" aria-label="Permalink to &quot;ESM可以运行时的import()&quot;">​</a></h2><p><code>import()</code> 函数可以用在任何地方。它是运行时执行，什么时候运行到这一句，也会加载指定的模块。另外，<code>import()</code> 函数与所加载的模块没有静态连接关系（人话就是import()不会返回指定变量，而是返回整个文件的输出），这点也是与 <code>import</code> 语句不相同。</p><p><code>import()</code> 类似于 <code>nodejs</code> 的 <code>require</code> 方法，区别主要是前者是异步加载，后者是同步加载（就是require一定会加载结束才往下走，而import()不await住的话会异步执行）</p><blockquote><p>所以nodejs环境 <code>Commonjs</code>可以被<code>await import()</code>完全替代了？</p></blockquote><h2 id="es6与commonjs的区别" tabindex="-1">ES6与CommonJS的区别 <a class="header-anchor" href="#es6与commonjs的区别" aria-label="Permalink to &quot;ES6与CommonJS的区别&quot;">​</a></h2><ul><li>CommonJS 模块输出的是一个值的拷贝(深拷贝)</li><li>ES6 模块输出的是值的引用（变量的指针）</li><li></li><li>CommonJS 模块是运行时加载</li><li>ES6 模块是编译时输出接口</li></ul><p><strong>ESM对工程化最大的好处是浏览器直接支持模块化代码的编写</strong> 如下依靠ESM不安装任何依赖直接使用react框架，</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  import </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> html</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> Component</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> render </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> from &#39;https://unpkg.com/htm/preact/standalone.module.js&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">  class App extends Component </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">setState</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">render</span><span style="color:#A6ACCD;">() </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">      return html</span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#F07178;">        &lt;div class=&quot;app&quot;&gt;</span></span>
<span class="line"><span style="color:#F07178;">          &lt;div&gt;count: </span><span style="color:#89DDFF;">\${</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">&lt;/div&gt;</span></span>
<span class="line"><span style="color:#F07178;">          &lt;button onClick=</span><span style="color:#89DDFF;">\${</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">add</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">&gt;Add Todo&lt;/button&gt;</span></span>
<span class="line"><span style="color:#F07178;">        &lt;/div&gt;</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;">;</span></span>
<span class="line"><span style="color:#F07178;">    }</span></span>
<span class="line"><span style="color:#F07178;">  }</span></span>
<span class="line"><span style="color:#F07178;">  render(</span><span style="color:#82AAFF;">html</span><span style="color:#89DDFF;">\`</span><span style="color:#F07178;">&lt;</span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">App</span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> page=&quot;All&quot; /&gt;</span><span style="color:#89DDFF;">\`</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> document.body);</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/script&gt;</span></span></code></pre></div><h2 id="esm的限制与解决方案" tabindex="-1">esm的限制与解决方案 <a class="header-anchor" href="#esm的限制与解决方案" aria-label="Permalink to &quot;esm的限制与解决方案&quot;">​</a></h2><h3 id="代码需要基于es开发" tabindex="-1">代码需要基于es开发 <a class="header-anchor" href="#代码需要基于es开发" aria-label="Permalink to &quot;代码需要基于es开发&quot;">​</a></h3><h3 id="第三方资源的导出要支持esm" tabindex="-1">第三方资源的导出要支持ESM <a class="header-anchor" href="#第三方资源的导出要支持esm" aria-label="Permalink to &quot;第三方资源的导出要支持ESM&quot;">​</a></h3><p>第三方资源node_module或者CDN的模块要可以通过import加载到</p><h3 id="不支持esm的浏览器" tabindex="-1">不支持esm的浏览器 <a class="header-anchor" href="#不支持esm的浏览器" aria-label="Permalink to &quot;不支持esm的浏览器&quot;">​</a></h3><p>不支持esm的浏览器会跳过<code>type=module</code>的js 这时再html写多一个<code>bundle.js</code> <code>commonjs规范</code>的代码资源兼容即可 浏览器提供一个标签属性<code>&lt;script nomodule src=&quot;&quot;&gt;</code>会判断是否支持esm，不支持则加载该标签</p><p><a href="https://github.com/systemjs/systemjs" target="_blank" rel="noreferrer">systemjs</a>实现兼容方案</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">system.js</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">systemjs-importmap</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  &quot;imports&quot;: {</span></span>
<span class="line"><span style="color:#A6ACCD;">    &quot;lodash&quot;: &quot;https://unpkg.com/lodash@4.17.10/lodash.js&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">type</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">systemjs-module</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>加载这个库后，用type=&quot;systemjs-module&quot;，会根据浏览器支持esm的情况处理代码</p><h2 id="思考" tabindex="-1">思考 <a class="header-anchor" href="#思考" aria-label="Permalink to &quot;思考&quot;">​</a></h2><h3 id="_1-webpack工程下怎么同时支持commonjs和esm规范" tabindex="-1">1. webpack工程下怎么同时支持CommonJs和ESM规范 <a class="header-anchor" href="#_1-webpack工程下怎么同时支持commonjs和esm规范" aria-label="Permalink to &quot;1. webpack工程下怎么同时支持CommonJs和ESM规范&quot;">​</a></h3><p>提示：webpack通过编译(不等于上面说的js引擎的编译)CMD和ESM的源代码做资源收集合并，再利用js插入script的形式来做整合过的模块化</p><p>开发编写的是Commonjs和ESM，最后上线的代码既不是CMD也不是ESM，而是打包后的插入script方法(webpack干的)</p><h3 id="_2-babel如何把esm编译成commonjs-在node环境中运行" tabindex="-1">2. babel如何把esm编译成commonjs，在node环境中运行 <a class="header-anchor" href="#_2-babel如何把esm编译成commonjs-在node环境中运行" aria-label="Permalink to &quot;2. babel如何把esm编译成commonjs，在node环境中运行&quot;">​</a></h3><p><a href="https://www.imyangyong.com/blog/2020/11/javascript/Babel%20%E4%B9%8B%20ESM%20%E5%92%8C%20CommonJS/" target="_blank" rel="noreferrer">Babel 之 ESM 和 CommonJS</a></p><h3 id="_3-webpack、rollup是怎么支持tree-shaking" tabindex="-1">3. webpack、rollup是怎么支持tree shaking <a class="header-anchor" href="#_3-webpack、rollup是怎么支持tree-shaking" aria-label="Permalink to &quot;3. webpack、rollup是怎么支持tree shaking&quot;">​</a></h3><p>提示：ESM因为命令式语法发生在编译时根据指针接收变量，即本身就是不引入额外的变量，也就是不需要做<code>tree shaking</code>这个动作，但是打包工具最终上线的不是ESM，且即使代码写的CJS，上线后也能实现<code>tree shaking</code></p><hr><h2 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h2><ul><li><a href="https://jakearchibald.com/2017/es-modules-in-browsers/" target="_blank" rel="noreferrer">ECMAScript modules in browsers</a></li><li><a href="https://zhuanlan.zhihu.com/p/26567790" target="_blank" rel="noreferrer">JavaScript 模块现状</a></li><li><a href="https://github.com/developit/htm" target="_blank" rel="noreferrer">基于esm、html、unpkg的前端开发模式</a></li><li><a href="https://timdaub.github.io/2021/01/16/web-principles/" target="_blank" rel="noreferrer">How I Build JavaScript Apps In 2021</a></li><li><a href="https://estimator.dev/" target="_blank" rel="noreferrer">Find out how much turning on modern JS could save.</a></li><li><a href="https://zhuanlan.zhihu.com/p/96718777" target="_blank" rel="noreferrer">什么是amd、commonjs、umd、esm?</a></li><li><a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/" target="_blank" rel="noreferrer">ES modules: A cartoon deep-dive</a></li><li><a href="https://github.com/WICG/import-maps" target="_blank" rel="noreferrer">import.map</a></li><li><a href="https://topic.atatech.org/articles/202736" target="_blank" rel="noreferrer">面对 ESM 的开发模式，webpack 还有还手之力吗?</a></li></ul>`,98),y=[e,t,c,r];function F(D,i,C,A,d,u){return l(),o("div",null,y)}const f=n(p,[["render",F]]);export{h as __pageData,f as default};
