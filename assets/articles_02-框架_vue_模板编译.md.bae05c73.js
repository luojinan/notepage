import{_ as s,o as a,c as n,V as l}from"./chunks/framework.b450deef.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/02-框架/vue/模板编译.md","filePath":"articles/02-框架/vue/模板编译.md"}'),o={name:"articles/02-框架/vue/模板编译.md"},p=l(`<p>在 <a href="./重学vue-01模板语法.html">重学vue-01模板语法</a> 中，我们知道了Vue对外的版本分为完整版和runtime版，完整版比runtime版多了模板编译器</p><blockquote><p>用打包工具时，最终打好的包里实际上是不需要编译器的，所以只用运行时版本即可.</p><p>因为运行时版本相比完整版体积要小大约 30%，所以应该尽可能使用这个版本,打包工具引入的资源默认是运行时版本的</p></blockquote><p>这大出来30%的编译器，能让我们写<code>template字符串</code>,在浏览器运行时解析成 <code>render函数</code> 再执行生成 <code>VNode</code>，渲染生成 <code>真实DOM</code></p><p>我们尝试实现这部分的编译器(<code>template字符串</code> -&gt; <code>render函数体</code>) 分析阶段</p><ul><li>解析器</li><li>优化器</li><li>代码生成器</li></ul><h2 id="解析器" tabindex="-1">解析器 <a class="header-anchor" href="#解析器" aria-label="Permalink to &quot;解析器&quot;">​</a></h2><blockquote><p>把模板字符串解析层AST对象</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">compiler</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">template</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">init</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">template</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">parseHTML</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">template</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;font-style:italic;">hookObj</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">template</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">init</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">template</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">parseHTML</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">template</span><span style="color:#89DDFF;">,{</span></span>
<span class="line"><span style="color:#F07178;">      startHook</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">startHook</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 标签开始时触发钩子</span></span>
<span class="line"><span style="color:#F07178;">      endHook</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 标签结束时触发钩子</span></span>
<span class="line"><span style="color:#F07178;">      stringHook</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 字符串时触发钩子</span></span>
<span class="line"><span style="color:#F07178;">      commentHook</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{},</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 注释时触发钩子</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">compiler</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">&lt;div&gt;1&lt;/div&gt;</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>解析器的内部原理是一小段一小段地截取模板字符串，每截取一小段字符串，就会根据截取出来的字符串类型触发不同的钩子函数，直到模板字符串截空停止运行</p><h2 id="优化器" tabindex="-1">优化器 <a class="header-anchor" href="#优化器" aria-label="Permalink to &quot;优化器&quot;">​</a></h2><blockquote><p>遍历AST标记静态节点</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">optimize</span><span style="color:#A6ACCD;"> (AST) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">AST</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 第一步：标记所有静态节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">markStatic</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">AST</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 第二步：标记所有静态根节点</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">markStaticRoots</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">AST</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="代码生成器" tabindex="-1">代码生成器 <a class="header-anchor" href="#代码生成器" aria-label="Permalink to &quot;代码生成器&quot;">​</a></h2><blockquote><p>遍历AST 生成并拼接字符串，<code>new Function</code>创建出render函数</p></blockquote><h2 id="打包工具的编译" tabindex="-1">打包工具的编译 <a class="header-anchor" href="#打包工具的编译" aria-label="Permalink to &quot;打包工具的编译&quot;">​</a></h2><blockquote><p>除了👆完整版vue里有模版语法的编译器,依靠打包工具来编译的模板语法的编译器，我们也来看看</p></blockquote><p>同样的<code>vue-loader</code>，解析出<code>.vue</code>文件中的<code>template</code>部分出来后，会进行转译成AST，打标记，生成render字符串等步骤</p><p>思考🤔: template配置的那种写法也是vue-loader做的编译吗</p>`,18),e=[p];function t(c,r,F,y,i,D){return a(),n("div",null,e)}const C=s(o,[["render",t]]);export{d as __pageData,C as default};
