import{_ as e,o,c,V as d}from"./chunks/framework.b450deef.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/03-架构/webpack/重学webpack-00有趣的点.md","filePath":"articles/03-架构/webpack/重学webpack-00有趣的点.md"}'),s={name:"articles/03-架构/webpack/重学webpack-00有趣的点.md"},a=d('<p>重新学习webpack,旨在理解运行webpack，是怎么编译目录下的各种文件的,如何做到接入各种 loader 和plugin</p><p>在重新学习之前还是要明确webpack的概念，webpack是个模块打包工具</p><p>模块化编程催生了打包工具的产生</p><p>安装 <code>webpack-cli</code> , 是为了可以在命令行中运行webpack <code>node_modules/.bin</code> 目录下的依赖不就是可以在命令行通过 <code>npx</code> 来运行了吗？ 也就webpack依赖不会默认放到.bin中,而是单独通过一个 <code>webpack-cli</code>的依赖来支持命令行运行？</p><p>从 <code>webpack-cli</code> 依赖的作用可以得出：如果项目通过一个js脚本运行webpack打包,则不需要安装该依赖</p><blockquote><p>小tips: 如果要研究打包后的js代码，可以把build阶段的mode环境配置成dev，让打包后代码不被压缩和混淆</p></blockquote><hr><h3 id="各种cssloader的作用" tabindex="-1">各种cssloader的作用 <a class="header-anchor" href="#各种cssloader的作用" aria-label="Permalink to &quot;各种cssloader的作用&quot;">​</a></h3><ul><li>style-loader: 把处理后的css文件内容插入到<code>html</code>的<code>head</code>中</li><li>css-loader: 处理css中的模块化,如<code>背景图</code>和<code>@import css</code>的操作</li><li>sass-loader: 预处理器样式语法的解析器</li><li>postcss-loader: 类似babel对js的作用,通过给样式属性添加前缀来兼容各种高低版本的浏览器</li></ul><p>👆 提到的css-loader 处理css中的模块化, 是css中资源的模块化, 当在js中引入css并且想要模块化(局部样式互不影响)就是不同的概念了 <a href="https://github.com/css-modules/css-modules" target="_blank" rel="noreferrer">css-modules - github</a>的概念</p><blockquote><p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。 产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。</p></blockquote><p><a href="https://vue-loader.vuejs.org/zh/guide/css-modules.html" target="_blank" rel="noreferrer">css-modules - vue</a></p><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220206220430.png" alt=""><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220206213958.png" alt=""><code>css-loader</code>提供此功能配置项,可以让css的<code>className</code>被编译成<code>hash</code>唯一值,<code>css-loader</code>针对这一功能还有更多配置项,如自定义编译后的<code>className</code>不至于是一大段很丑的<code>hash</code>,详细看<a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html" target="_blank" rel="noreferrer">css modules - 阮一峰</a></p><blockquote><p>感觉在<code>react</code>中用得更多，<code>vue2</code>中用<code>render</code>写<code>jsx</code>的<code>js文件</code>可能也需要用到 但是到<code>vue3</code>之后都是<code>.vue</code>文件中写<code>jsx</code>?</p></blockquote><hr><blockquote><p><code>plugin</code>类似生命周期,如<code>htmlWebpackPlugin</code>在打包结束时生成一个html文件并引入出口js 所以编写<code>plugin</code>配置数组时并不需要在意编写顺序，<code>plugin</code>执行时机取决于<code>plugin</code>自身，可以去具体的<code>plugin</code>的文档中查看</p></blockquote><hr><p>sourceMap是如何在运行打包后代码还能定位到源代码位置的</p><p>配置<code>devTool</code>为<code>source-map</code>时, 打包后资源会多一个<code>.map</code>文件映射打包后代码和源代码 而<code>devTool</code>改为<code>inline-source-map</code>, 打包后资源不会多文件，而是多一段注释代码在打包后代码最末端，这段注释就是<code>base64</code>后的<code>.map</code>文件内容</p><blockquote><p>eval是怎么实现的？有一个特殊的配置为 eval, 这跟.map效果一样能定位到源代码的位置，但是是完全不同的原理不是通过.map或者注释的base64来定位，而是在 sourceURL=webpack://...</p></blockquote><hr><p>webpack-dev-server 为什么不像build一样生成一个dist, 因为电脑读写文件比起修改内存要更耗性能,因为为了提升频繁修改文件的编译速度,dev阶段会把资源生成到内存中</p><p>webpack5之后可以通过地址拼接dev-server在浏览器查看内存中的打包后目录情况</p><hr><p>热更新 在业务代码里其实需要写一段webpack热更新代码 <img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220206232544.png" alt=""></p><p>但是很多loader会帮忙注入实现，就不用手写，如css-loader和vue-loader，只要开启devserver的热更新，就可以实现局部热更新(如果没有loader的支持,开启后还要手写一段热更新的代码)</p><blockquote><p>react 则是靠babel的预设preset实现的注入热更新代码</p></blockquote><p><strong>热更新原理：</strong></p><hr><p>treeShaking</p><p>webpack能让<code>CommonJs</code>支持<code>treeShaking</code>吗？怎么实现？</p><p>开启<code>treeShaking</code>后会摇掉没有使用的资源内容，而有些资源是不抛出内容或是挂载到全局变量上的,就会被摇掉, 而我们想要保留时配置 <code>sideEffects</code> 如在js中引入css 就会被摇掉 <code>sideEffects: [&quot;*.css&quot;]</code></p><p>prod阶段自动开启<code>treeShaking</code>, dev阶段为了频繁修改的编译速度和<code>sourceMap</code>的映射关系会默认关闭<code>treeShaking</code>，可以通过配置让dev阶段开启<code>treeShaking</code>，查看打包后代码如下，dev阶段即使开启<code>treeShaking</code>也不会摇掉代码而是注释提示只用到了哪些内容 <img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220206234433.png" alt=""></p><p>理解chunk的概念，可以帮助我们配置webpack，因为webpack很多关键值key用了chunks 比如code spliting 中的minChunks 最小使用次数：指的是打包后的每个js文件对目标的使用次数，并不是源代码中的js文件使用次数</p><hr><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220207210553.png" alt=""> 视频漏了这个些部分</p><hr><p>webpack打包速度优化 把第三方资源库只打包一次，后续都不用再对第三方资源进行打包</p><ol><li>手动打包或是使用官方CDN，在模板html上写死引入</li><li>使用DDLplugin,手动运行一次打包第三方资源。再打包工程时跳过打包第三方资源，直接去打包后第三方资源中引入(还是要插入到html中,只不过节省了从node_modules打包资源的步骤)</li></ol><p>ddlPlugin 跟 CDN比 ddlPlugin 跟 手动写loadResource(&#39;./swiper.min.js&#39;)比</p><hr><p>webpack编写loader，对着文档并不是很难写,就是根据webpack提供的参数操作数据</p><p>重点要学的是webpack的底层如何支持loader的</p><hr><hr><p>讲解webpack原理的视频</p><ul><li><p>收集js的依赖关系成一个数组对象(不使用递归而是队列)</p></li><li><p>遍历模块依赖关系数组,用立即执行js注入require等参数实现浏览器支持CMD(参考手写CommonJs)</p></li><li><p>立即执行函数是用字符串写成的，最终写入一个js文件中</p></li><li><p>扩展中间支持loader的调用</p></li><li><p>加入babel loader</p></li></ul><p>从👆看，webpack把很多功能都通过loader和plugin开放出去了，自身只实现让浏览器支持CJS的模块化而已,为什么会这么重呢(因为工程庞大,依赖文件多？)</p>',48),p=[a];function l(r,t,i,n,u,b){return o(),c("div",null,p)}const m=e(s,[["render",l]]);export{k as __pageData,m as default};
