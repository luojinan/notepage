import{_ as o,o as e,c as t,V as c}from"./chunks/framework.b450deef.js";const _=JSON.parse('{"title":"JS 基础","description":"","frontmatter":{},"headers":[],"relativePath":"articles/04-面试/题库/JS基础.md","filePath":"articles/04-面试/题库/JS基础.md"}'),i={name:"articles/04-面试/题库/JS基础.md"},a=c('<h1 id="js-基础" tabindex="-1">JS 基础 <a class="header-anchor" href="#js-基础" aria-label="Permalink to &quot;JS 基础&quot;">​</a></h1><h2 id="js-数据类型" tabindex="-1">JS 数据类型 <a class="header-anchor" href="#js-数据类型" aria-label="Permalink to &quot;JS 数据类型&quot;">​</a></h2><blockquote><p>原始类型有哪几种？null 是对象嘛？</p></blockquote><p><strong>原始类型</strong> 6种基础/原始类型：<code>boolean</code>、<code>null</code>、<code>undefined</code>、<code>number</code>、<code>string</code>、<code>symbol</code></p><p>原始类型存储的都是值，是没有函数可以调用的，比如 <code>undefined.toString()</code> 会报错</p><p><code>&#39;1&#39;.toString()</code> 是可以使用的。其实在这种情况下，<code>&#39;1&#39;</code> 已经不是原始类型了，而是被强制转换成了 <code>String</code> 类型也就是对象类型，所以可以调用 <code>toString</code> 函数。</p><p><code>string</code> 类型是不可变的，无论你在 <code>string</code> 类型上调用何种方法，都不会对值有改变。</p><p>另外对于 <code>null</code> 来说，很多人会认为他是个对象类型，其实这是错误的。虽然 <code>typeof null</code> 会输出 <code>object</code>，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p><p><strong>对象类型</strong></p><blockquote><p>对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？</p></blockquote><p>对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）</p><h2 id="js-数据类型判断" tabindex="-1">JS 数据类型判断 <a class="header-anchor" href="#js-数据类型判断" aria-label="Permalink to &quot;JS 数据类型判断&quot;">​</a></h2><blockquote><p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code> 能正确判断对象的原理是什么？</p></blockquote><ul><li>typeof 判断基础/原始类型,null 会判断成obj, 其他都能正确</li><li>typeof 判断对象类型,函数会判断成 function,其他都正确时obj,但是判断不了具体的类型</li></ul><p><code>instanceof</code> 原理：TODO:</p><h2 id="数据类型隐式转化" tabindex="-1">数据类型隐式转化 <a class="header-anchor" href="#数据类型隐式转化" aria-label="Permalink to &quot;数据类型隐式转化&quot;">​</a></h2><p>TODO:</p><h2 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h2><blockquote><p>如何正确判断 this？箭头函数的 this 是什么？</p></blockquote><p><img src="https://kingan-md-img.oss-cn-guangzhou.aliyuncs.com/blog/20220219170631.png" alt=""></p><ul><li><p>直接调用 foo ，不管 foo 函数被放在了什么地方，this 一定是 window</p></li><li><p>obj.foo() ，我们只需要记住，谁调用了函数，谁就是 this，this 是 obj 对象</p></li><li><p>new 的方式，this 被永远绑定在了 new 出来的变量上面，不会被任何方式改变 this</p></li><li><p>箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this (因为箭头函数没有this,因此对包裹箭头函数的函数使用bind也无法修改this)</p></li><li><p>new 一个class内部的对象的函数的箭头函数，这种情况根据优先级</p></li><li><p>new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是直接调用的方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p></li></ul><blockquote><p>tips: <code>fn.bind(a).bind(b)</code> 不会修改多次this指, 只有第一个会生效, 具体原因请手写bind</p></blockquote>',22),d=[a];function l(n,s,p,r,h,u){return e(),t("div",null,d)}const f=o(i,[["render",l]]);export{_ as __pageData,f as default};
