import{_ as e,o,c,V as d}from"./chunks/framework.b450deef.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/03-架构/performance/ssr.md","filePath":"articles/03-架构/performance/ssr.md"}'),r={name:"articles/03-架构/performance/ssr.md"},t=d('<blockquote><p>关于SSR的🤔：</p><p>各前端框架官方提供的 <code>SSR</code> 功能，不动业务源码，新增一层抹平层 <code>nodejs环境</code> 和 <code>浏览器环境</code>，实现一套代码打包2个产物支持 <code>浏览器</code> 和 <code>nodejs环境</code></p></blockquote><blockquote><p>就很类似现在做的<code>一码两端</code>(一套代码打包2个产物支持 <code>浏览器环境</code> 和 <code>APP webView</code> 环境)</p><p>或者 <code>微前端</code>，不动多个内管应用的业务源码，整合到一起，新增一层抹平层</p></blockquote><blockquote><p>因此学习官方提供的 <code>SSR</code> 底层原理，如何优雅的实现抹平层，可以很好的帮助自身的架构能力</p></blockquote><p><a href="https://cn.vuejs.org/guide/scaling-up/ssr.html" target="_blank" rel="noreferrer">Vue官方文档-SSR</a></p><p>学习 Vue 原理时都会有一大章节讲解运行时浏览器 渲染器(把 <code>template</code> 转译为 <code>render函数</code>, 执行 <code>render函数</code> 渲染<code>真实DOM</code>)</p><p>而 SSR 则是在静态服务器响应时 渲染器(把 <code>template</code> 转译为 <code>render函数</code>, 执行 <code>render函数</code> 渲染成 <code>html字符</code>)， 并且 浏览器运行时需要对这些 <code>html字符</code> 做 <code>激活(hydrate)</code> 处理</p><p>而 一些在静态服务器响应时 还要调接口或数据处理操作 的时候，意味着</p><ul><li>静态服务器也需要执行源码的逻辑</li><li>浏览器运行时也要执行源码的逻辑 👆 这种现象称为 <code>同构的(Isomorphic)</code> 或 <code>通用的(Universal)</code></li></ul><p>缺点： 同构资源的处理 劣势在于程序需要具有通用性。结合 Vue 的钩子来说，能在 SSR 中调用的生命周期只有 beforeCreate 和 created，这就导致在使用三方 API 时必须保证运行不报错。在三方库的引用时需要特殊处理使其支持服务端和客户端都可运行。</p><p>部署构建配置资源的支持 劣势在于运行环境单一。程序需处于 node.js server 运行环境。</p><p>服务器更多的缓存准备 劣势在于高流量场景需采用缓存策略。应用代码需在双端运行解析，cpu 性能消耗更大，负载均衡和多场景缓存处理比 SPA 做更多准备。</p>',11),p=[t];function s(a,l,n,_,i,u){return o(),c("div",null,p)}const f=e(r,[["render",s]]);export{S as __pageData,f as default};
