import{_ as e,o as l,c as o,V as a}from"./chunks/framework.b450deef.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"articles/03-架构/设计/深入babel.md","filePath":"articles/03-架构/设计/深入babel.md"}'),r={name:"articles/03-架构/设计/深入babel.md"},s=a(`<p>TODO: 过一遍官方文档,包括所有插件转译后代码是如何替代高级语法的 看看github中的preset集成了什么</p><p>转译过程：ES6 -&gt; AST -&gt; ES5 [toc]</p><ul><li>babylon解析 <code>ES6</code> 成 <code>AST</code></li><li>babel的插件<code>plugin</code> 遍历转译 <code>AST</code> 成<code>ES5</code>的<code>AST</code></li><li>babel的<code>generator</code>生成器 把<code>AST</code>转成<code>ES5</code></li></ul><p>因为babel的设计原则是原子化的，所以我们用的时候会发现写好几个babel的东西，实际上还可以写得更多...</p><p>要用babel实现<code>ES6的AST</code>转<code>ES5的AST</code>转译，我们需要很多babel的插件(原子化)</p><ul><li>转译语法类型(let、class、箭头函数等)的plugin</li><li>转译api类型(promise)的plugin</li></ul><p>这两类的plugin都很零散，babel提供了plugin的集合给我们使用，而我们的工程里面经常配置的babel相关的配置就是配置集合的参数</p><p>语法类型的集合是预设preset api类型的集合是垫片polyfill (渐渐抛弃polyfill，都由preset配置了)</p><p>@babel/cli 是为了在node环境运行转译的启动工具 @babel/core 是所有转译的核心代码</p><p>@babel/preset-env 预设插件组合 包含generrx-time？ ⬆️已经包含了polyfill的功能并且不需要手动安装polyfill而是内部集成了？</p><h3 id="预设preset" tabindex="-1">预设preset <a class="header-anchor" href="#预设preset" aria-label="Permalink to &quot;预设preset&quot;">​</a></h3><blockquote><p>预设是一组<code>babel</code>插件的集合，用大白话讲就是插件包</p></blockquote><p>假如我们引用了一组预设preset，又引用了一个plugin 我们已经知道预设preset就是一组plugin，如果再引入进来的plugin处理的对象和preset处理的对象相同 那么处理顺序是怎样的？谁会覆盖谁？</p><ul><li>plugin比preset先执行</li><li>plugin之间的顺序是:从前往后</li><li>preset之间的顺序是:从后往前</li></ul><h4 id="配置-browserslistrc" tabindex="-1">配置：browserslistrc <a class="header-anchor" href="#配置-browserslistrc" aria-label="Permalink to &quot;配置：browserslistrc&quot;">​</a></h4><p>在工程包里，打包工具有很多<code>webpack-loader</code>或者<code>webpack-plugin</code>依赖到一个配置<code>browserslistrc</code>的配置，可以是单独的文件也可以是<code>package.json</code>里的配置 <code>Autoprefixer、postcss</code>这些loader就用到了这个配置判断编译css是否要加前缀 而babel的presetenv也用到工程下的这个配置，当然也可以在babel中配置覆盖掉工程的配置 很多脚手架默认会配置成<code>&gt;1% not ie&lt;=8</code> 可以配置成谷歌具体的版本 <code>chrome 60</code> 这样就不会去编译箭头函数等语法，减少打包体积</p><p>⬇️并且可以给<code>useBuiltins</code>配置自动按浏览器版本引入转译api用的plugin组合</p><h4 id="配置-usebuiltins" tabindex="-1">配置：useBuiltins <a class="header-anchor" href="#配置-usebuiltins" aria-label="Permalink to &quot;配置：useBuiltins&quot;">​</a></h4><ul><li>entry会按需(根据浏览器配置)引入polyfill?需要配合import和webpack的treeshaking</li><li>usage不需要手动引入polyfill，会自动根据代码中用到的高级api按需(根据浏览器配置和代码实际使用)引入<code>corejs</code>中的工具方法</li></ul><h4 id="配置-corejs-2-3" tabindex="-1">配置：corejs 2/3 <a class="header-anchor" href="#配置-corejs-2-3" aria-label="Permalink to &quot;配置：corejs 2/3&quot;">​</a></h4><p>默认2 ? 配了2，工程里只有3怎么办？这个配置没必要吧。工程的corejs是几就是几吧，又不会同时存在</p><p>TODO: ?注意：这些配置，可以让转译过程按浏览器和配置需要按需转译，但是<code>polyfill</code>或者<code>corejs</code>和<code>generator-runtime</code>还是要手动引入打包工具中的</p><p>babel可以设置把esm编译成其他模块化 但是一般不建议，保留esm可以给其他阶段做treeshaking 不设置会默认转成require，Commonjs的模块化规范，那么以前webpack是对require做treeshaking的吗？</p><h4 id="plugin-transform-runtime" tabindex="-1">plugin-transform-runtime <a class="header-anchor" href="#plugin-transform-runtime" aria-label="Permalink to &quot;plugin-transform-runtime&quot;">​</a></h4><p>presetenv编译语法时可能会往文件注入辅助函数，如class。这样会导致大量重复代码，@babel/runtime提前把所有辅助函数打包起来了，用到的辅助函数去引用这个包相应的辅助函数即可。</p><p>plugin-transform-runtime就是识别到需要辅助函数时去引用@babel/runtime里的辅助函数，让persetenv不要直接注入函数。(还是要手动安装@babel/runtime，但是不用配置它，配置了transform-runtime会自动找它)</p><p>因此需留意<code>transform-runtime</code>和<code>runtime</code>的区别 babel-plugin-transform-runtime插件依赖babel-runtime，babel-runtime是真正提供runtime环境的包；也就是说transform-runtime插件是把js代码中使用到的高级语法转译低级语法的辅助函数转换成对runtime实现包的引用，举个例子如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 输入的ES6代码</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> sym </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Symbol</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 通过transform-runtime转换后的ES5+runtime代码 </span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> _symbol </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">babel-runtime/core-js/symbol</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> sym </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> (</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> _symbol</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">default)()</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>从上面这个例子可见，原本代码中使用的ES6新原生对象Symbol被transform-runtimec插件转换成了babel-runtime的实现，既保持了Symbol的功能，同时又没有像polyfill那样污染全局环境（因为最终生成的代码中，并没有对Symbol的引用） 另外，这里我们也可以隐约发现，babel-runtime其实也不是真正的实现代码所在，真正的代码实现是在core-js中</p><p>transform-runtime插件的功能</p><ol><li>把代码中的使用到的ES6引入的新原生对象和静态方法用babel-runtime/core-js导出的对象和方法替代</li><li>当使用generators或async函数时，用babel-runtime/regenerator导出的函数取代（类似polyfill分成regenerator和core-js两个部分）</li><li>把Babel生成的辅助函数改为用babel-runtime/helpers导出的函数来替代（babel默认会在每个文件顶部放置所需要的辅助函数，如果文件多的话，这些辅助函数就在每个文件中都重复了，通过引用babel-runtime/helpers就可以统一起来，减少代码体积）</li></ol><p>上述三点就是transform-runtime插件所做的事情，由此也可见，babel-runtime就是一个提供了regenerator、core-js和helpers的运行时库。</p><p>此外，transform-runtime在.babelrc里配置的时候，还可以设置helpers、polyfill、regenerator这三个开关，以自行决定runtime是否要引入对应的功能。 最后补充一点：由于runtime不会污染全局空间，所以通过直接引入runtime里的方法来使用实例方法是无法工作的（因为这必须在原型链上添加这个方法，这是和polyfill最大的不同）</p><p>为什么不让presetenv注入到业务代码后，通过webpack打包时发现是重复代码，抽出成包，就可以节省一个babel的plugin？</p><p>这里对webpack的原理不清楚，以为webpack是通过扫描代码中的重复代码进行分包的。而实际上每个文件声明相同内容的函数或者引用类型变量，都是新的堆内存，没人可以说他们是重复。webpack也不能，webpack的分包是基于模块化的esm或者commonjs规范，所以要不同文件复用代码，就需要模块化打包，所以写法是通过一个完整包，再去按需引入内容，也就是手动分包。webpack的作用是模块化的本质是合并引入的文件内容，所以不同文件引入重复的文件会合并进去，而webpack就能把要合并多次的文件抽离到公共包，也是去重</p><h3 id="垫片polyfill" tabindex="-1">垫片polyfill <a class="header-anchor" href="#垫片polyfill" aria-label="Permalink to &quot;垫片polyfill&quot;">​</a></h3><blockquote><p>polyfill并不是babel特属的东西，而是指:为环境提供不支持的特性的一类文件或库。也就是polyfill是一种功能</p></blockquote><p><code>babel</code>的<code>polyfill</code>也和其他<code>polyfill</code>一样，支持直接引入一个js资源或者引用npm依赖</p><p>引入js资源形式没什么好讲的，主要看npm依赖形式。</p><h4 id="babel-polyfill" tabindex="-1">@babel/polyfill <a class="header-anchor" href="#babel-polyfill" aria-label="Permalink to &quot;@babel/polyfill&quot;">​</a></h4><blockquote><p><code>@babel/polyfill</code>的npm依赖，本质只是组合一下<code>corejs</code>和<code>regenerator-runtime</code>而已</p></blockquote><p>babel7之后，官方建议不要使用<code>@babel/polyfill</code>，而是自己手动组合<code>corejs3</code>和<code>regenerator-runtime</code> 原因是<code>@babel/polyfill</code>使用的是<code>corejs2</code>，且表明不会更新成<code>corejs3</code> 所以<code>@babel/polyfill</code>一定会渐渐跟不上新的api</p><p>对于已经用着的。<code>@babel/polyfill</code>非常大，如果可以保证用户浏览器版本高足够支持大部分es6语法，就没必要引用整个使用<code>@babel/polyfill</code>。而是通过plugin和preset手动组合需要plugin</p><h3 id="corejs" tabindex="-1">corejs <a class="header-anchor" href="#corejs" aria-label="Permalink to &quot;corejs&quot;">​</a></h3><p>core-js包才上述的polyfill、runtime的核心，因为polyfill和runtime其实都只是对core-js和regenerator的再封装，方便使用而已。 但是polyfill和runtime都是整体引入的，不能做细粒度的调整，如果我们的代码只是用到了小部分ES6而导致需要使用polyfill和runtime的话，会造成代码体积不必要的增大（runtime的影响较小）。所以，按需引入的需求就自然而然产生了，这个时候就得依靠core-js来实现了。</p><p>通过引入方式来实现不同的效果 ⬇️都是按需引入，只引入需要的转译方法xxx</p><ul><li>默认方式：require(&#39;core-js/xxx&#39;) 这种方式跟polyfill一样，是修改原型方法的</li><li>库的形式： var core = require(&#39;core-js/library/xxx&#39;) 这种方式只能用导出的方法来使用高级语法，而不能直接用原型方法</li></ul>`,47),p=[s];function n(t,i,c,b,d,u){return l(),o("div",null,p)}const f=e(r,[["render",n]]);export{y as __pageData,f as default};
